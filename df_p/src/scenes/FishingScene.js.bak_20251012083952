import Bait from '../entities/Bait.js';
import Fish from '../entities/Fish.js';
import { SaveManager } from '../core/SaveManager.js';

export default class FishingScene {
  mount(container, manager, state, data) {
    this.container = container;
    this.manager = manager;
    this.state = state;
    this._mode = (data && data.mode) || 'start';

    this.root = document.createElement('div');
    this.root.className = 'scene scene--fishing';
    this.root.innerHTML = `
      <div class="fish-layer frame-skin-default">
        <div class="fish-bg" aria-hidden="true">
          <video id="introVideo" src="assets/turigamennsyoki.mp4" autoplay muted playsinline webkit-playsinline preload="auto" loop></video>
        </div>

        <div class="safe-viewport"></div>

        <div class="frame-svg" aria-hidden="true"></div>

        <div class="topbar fish-topbar">
          <div class="topset" id="topsetGroup">
            <div class="left depth-group">
              <button class="img-combo-btn img-combo-btn--sm topset-item" id="btnBack" aria-label="TITLE">
                <picture>
                  <source srcset="assets/yajirushi.webp" type="image/webp" />
                  <img class="back-arrow" src="assets/yajirushi.png" alt="Back" />
                </picture>
                <picture>
                  <source srcset="assets/TITLE.webp" type="image/webp" />
                  <img class="back-title" src="assets/TITLE.png" alt="TITLE" />
                </picture>
              </button>
              <div class="depth current-depth topset-item">
                <picture>
                  <source srcset="assets/suisinhakari.webp" type="image/webp" />
                  <img class="depth-bg" src="assets/suisinhakari.png" alt="Depth" />
                </picture>
                <div class="depth-text" id="depthNow">00000</div>
              </div>
              <div class="depth max-depth topset-item">
                <picture>
                  <source srcset="assets/suisinhakari-max.webp" type="image/webp" />
                  <img class="depth-bg" src="assets/suisinhakari-max.png" alt="Max Depth" />
                </picture>
                <picture>
                  <source srcset="assets/MAX.webp" type="image/webp" />
                  <img class="depth-max-label" src="assets/MAX.png" alt="MAX" />
                </picture>
                <div class="depth-text" id="depthMax">00000</div>
              </div>
            </div>
            <div class="right right-group">
              <div class="esabako-mini topset-item" id="esabakoMini"></div>
            </div>
          </div>

          <div class="gamehud" id="gameHud" style="display:none">
            <div class="left depth-group">
              <div class="depth current-depth topset-item">
                <picture>
                  <source srcset="assets/suisinhakari.webp" type="image/webp" />
                  <img class="depth-bg" src="assets/suisinhakari.png" alt="Depth" />
                </picture>
                <div class="depth-text" id="depthNowGame">00000</div>
              </div>
            </div>
            <div class="right right-group">
              <div class="esabako-mini topset-item" id="esabakoMiniGame"></div>
            </div>
          </div>
        </div>
      </div>
    `;

    container.replaceChildren(this.root);
    // UI全体のY方向オフセット（負で上へ）
    const UI_OFFSET_Y_PX = -70; // 要望: 上に70px
    // UIオーバーライドCSS（深度数字を下へ15px/右へ5px、戻る矢印を1.3倍）
    try {
      const sid = 'df-fishing-ui-overrides';
      let st = document.getElementById(sid);
      if (!st) { st = document.createElement('style'); st.id = sid; document.head.appendChild(st); }
      st.textContent = `
        .scene--fishing .depth .depth-text{ left: calc(50% - 5px + 5px) !important; top: calc(50% - 3px + 62px) !important; }
        .scene--fishing .img-combo-btn--sm .back-arrow{ width: calc(clamp(58px, 11vw, 128px) * 1.3); }
        .scene--fishing .depth.max-depth .depth-max-label{ position:absolute; left: calc(50% - 5px + 5px); top: calc(50% - 3px + 62px - 6px); transform: translate(-50%, -100%); width: clamp(40px, 8vw, 90px); height:auto; image-rendering: pixelated; pointer-events:none; }
        /* タイトルへ戻るボタンだけ30px下げる */
        .scene--fishing #btnBack{ position: relative; top: 30px; }
        /* 餌箱の餌を7px下げる（ミニ&通常） */
        .scene--fishing .ebi-img-mini{ transform: translate(-30px, -13px) !important; }
        .scene--fishing .esabako-group .ebi-img{ transform: translate(-30px, -13px) !important; }
        /* TAPガイド（投げる前の点滅表示） */
        .scene--fishing .tap-guide{
          position:absolute; left: calc(50% + 100px); top: calc(42% - 130px + ${UI_OFFSET_Y_PX + 80}px);
          transform: translate(-50%, -50%);
          width: clamp(80px, 14vw, 220px);
          height:auto;
          image-rendering: pixelated;
          pointer-events: none;
          z-index: 9;
          animation: df-tap-blink 1.05s ease-in-out infinite;
          opacity: 0.9;
        }
        @keyframes df-tap-blink{
          0%,100%{ opacity: 0.35; }
          50%{ opacity: 1; }
        }
      `;
    } catch (_) {}

    // 水深メーターDOM参照＆表示関数
    this._depthNowEl = this.root.querySelector('#depthNow');
    this._depthNowGameEl = this.root.querySelector('#depthNowGame');
    this._depthMaxEl = this.root.querySelector('#depthMax');
    this._maxDepthMeters = 0;
    this._fmtDepth = (m) => {
      const v = Math.max(0, Math.min(99999, Math.floor(m || 0)));
      return String(v).padStart(5, '0');
    };
    this._renderDepth = () => {
      try { if (this._depthNowEl) this._depthNowEl.textContent = this._fmtDepth(this._depthMeters || 0); } catch(_) {}
      try { if (this._depthNowGameEl) this._depthNowGameEl.textContent = this._fmtDepth(this._depthMeters || 0); } catch(_) {}
      try { if (this._depthMaxEl) this._depthMaxEl.textContent = this._fmtDepth(this._maxDepthMeters || 0); } catch(_) {}
    };
    this._renderDepth();

    // フルスクリーン枠適用（アクアリウム以外で共通）
    document.body.classList.add('frame-full');

    // クリックイベント
    this.onBack = () => this.manager.goTo('title');
    this._btnBack = this.root.querySelector('#btnBack');
    if (this._btnBack) this._btnBack.addEventListener('click', this.onBack);
    // ESCキーでタイトルへ戻る
    this._onKeyDown = (ev) => {
      try {
        const k = ev.key || ev.code;
        if (k === 'Escape' || k === 'Esc') {
          ev.preventDefault?.();
          this.onBack?.();
        }
      } catch(_) {}
    };
    window.addEventListener('keydown', this._onKeyDown);
    // 戻るボタンの表示/非表示
    this._setBackVisible = (v) => {
      try { if (this._btnBack) this._btnBack.style.display = v ? '' : 'none'; } catch(_) {}
    };
    // トップセットのアニメーション
    this._animateTopSet = () => {
      try {
        const items = this.root.querySelectorAll('.topset-item');
        let delay = 0;
        items.forEach((el) => {
          el.style.animationDelay = `${delay}s`;
          el.classList.add('enter');
          delay += 0.05;
        });

      } catch(_) {}
    };

    // トップセットのフィット（可用幅に応じて縮小スケール）
    this._fitTopset = () => {
      try {
        const topbar = this.root.querySelector('.fish-topbar');
        const group = this.root.querySelector('#topsetGroup');
        if (!topbar || !group) return;
        const avail = Math.max(0, Math.floor(topbar.getBoundingClientRect().width || 0));
        // scrollWidth は実コンテンツ幅（縮小前）
        const desired = Math.max(0, Math.floor(group.scrollWidth || 0));
        let scale = 1;
        if (avail > 0 && desired > 0 && desired > avail) {
          scale = Math.max(0.6, avail / (desired + 2));
        }
        group.style.transformOrigin = 'left top';
        group.style.transform = `scale(${scale})`;
      } catch(_) {}
    };

    // トップセットの画像読み込みやサイズ変化に追従して再フィット
    this._installTopsetObservers = () => {
      try {
        const group = this.root.querySelector('#topsetGroup');
        if (!group) return;
        // ResizeObserverで幅変化を検知
        if (typeof ResizeObserver !== 'undefined') {
          try { this._topsetRO?.disconnect?.(); } catch(_) {}
          this._topsetRO = new ResizeObserver(() => { this._fitTopset?.(); });
          this._topsetRO.observe(group);
        }
        // 画像の読み込み完了で再フィット
        const imgs = group.querySelectorAll('img');
        imgs.forEach((im) => {
          try {
            const handler = () => { this._fitTopset?.(); };
            im.addEventListener('load', handler, { once: true });
            if (im.complete) this._fitTopset?.();
          } catch(_) {}
        });
        // 初期にも一度実行
        this._fitTopset?.();
      } catch(_) {}
    };

    // トップバー内: 餌箱ミニを生成
    this._spawnEsabakoMini = () => {
      try {
        const host = this.root.querySelector('#esabakoMini');
        if (!host) return;
        if (host.childElementCount) {
          // 再入場アニメ（クラスを付け直す）
          host.classList.remove('enter');
          void host.offsetWidth; // reflow
          host.classList.add('enter');
          this._esabakoMini = host; this._esabakoMiniTop = host;
          return;
        }
        const wrap = document.createElement('div');
        wrap.className = 'esabako-mini-wrap';
        wrap.innerHTML = `
          <picture>
            <source srcset="assets/esabako.webp" type="image/webp" />
            <img class="esabako-img-mini" src="assets/esabako.png" alt="esabako" />
          </picture>
          <img class="ebi-img-mini" src="assets/taiwoturuebi.png" alt="ebi" />
        `;
        host.appendChild(wrap);
        // ebiは動的に差し替えるため、webp優先+フォールバックを設定
        try {
          const ebiImg = host.querySelector('.ebi-img-mini');
          if (ebiImg) {
            ebiImg.decoding = 'async';
            const pngSrc = 'assets/taiwoturuebi.png';
            const webpSrc = 'assets/taiwoturuebi.webp';
            ebiImg.onerror = () => {
              if (ebiImg.src.endsWith('.webp')) { ebiImg.onerror = null; ebiImg.src = pngSrc; }
            };
            ebiImg.src = webpSrc;
          }
        } catch(_) {}
        this._esabakoMini = host; this._esabakoMiniTop = host;
        requestAnimationFrame(()=>{ host.classList.add('enter'); });
      } catch(_) {}
    };

    // ゲームHUD内: 餌箱ミニを生成
    this._spawnEsabakoMiniGame = () => {
      try {
        const host = this.root.querySelector('#esabakoMiniGame');
        if (!host) return;
        if (host.childElementCount) {
          host.classList.remove('enter');
          void host.offsetWidth;
          host.classList.add('enter');
          this._esabakoMiniGame = host;
          // 生成済みでも続きからの餌画像に更新
          try {
            const id = this.state?.bait?.id || this._pendingBaitId;
            if (id) this._setEsabakoById?.(id);
          } catch(_) {}
          return;
        }
        const wrap = document.createElement('div');
        wrap.className = 'esabako-mini-wrap';
        wrap.innerHTML = `
          <picture>
            <source srcset="assets/esabako.webp" type="image/webp" />
            <img class="esabako-img-mini" src="assets/esabako.png" alt="esabako" />
          </picture>
          <img class="ebi-img-mini" src="assets/taiwoturuebi.png" alt="ebi" />
        `;
        host.appendChild(wrap);
        this._esabakoMiniGame = host;
        requestAnimationFrame(()=>{ host.classList.add('enter'); });
        // コンティニュー時: 保存済みの餌IDで差し替え（デフォはエビになってしまうため）
        try {
          const id = this.state?.bait?.id || this._pendingBaitId;
          if (id) this._setEsabakoById?.(id);
        } catch(_) {}
        // ebiはwebp優先+フォールバック（保存済みの餌IDが無い場合のみ適用）
        try {
          const hasId = !!(this.state?.bait?.id || this._pendingBaitId);
          if (!hasId) {
            const ebiImg = host.querySelector('.ebi-img-mini');
            if (ebiImg) {
              ebiImg.decoding = 'async';
              const pngSrc = 'assets/taiwoturuebi.png';
              const webpSrc = 'assets/taiwoturuebi.webp';
              ebiImg.onerror = () => { if (ebiImg.src.endsWith('.webp')) { ebiImg.onerror = null; ebiImg.src = pngSrc; } };
              ebiImg.src = webpSrc;
            }
          }
        } catch(_) {}
      } catch(_) {}
    };

    // トップセットを引き上げて非表示
    this._hideTopset = () => {
      try {
        const group = this.root.querySelector('#topsetGroup');
        if (!group || group.style.display === 'none') return;
        const items = group.querySelectorAll('.topset-item');
        items.forEach(el => { el.classList.remove('enter'); void el.offsetWidth; el.classList.add('exit'); });
        setTimeout(()=>{ try { group.style.display = 'none'; } catch(_) {} }, 380);
      } catch(_) {}
    };

    // ゲームHUDを表示（左:現在水深 / 右:餌箱）
    this._showGameHud = () => {
      try {
        const hud = this.root.querySelector('#gameHud');
        if (!hud) return;
        hud.style.display = '';
        // 餌箱（ゲーム用）生成
        this._spawnEsabakoMiniGame?.();
        // アニメ入場
        const items = hud.querySelectorAll('.topset-item');
        let delay = 0;
        items.forEach((el) => { el.style.animationDelay = `${delay}s`; el.classList.add('enter'); delay += 0.03; });
        // 表示直後に水深を即時反映
        this._renderDepth?.();
      } catch(_) {}
    };
    // 餌が可視になったタイミングでHUDを表示
    this._showHudWhenBaitVisible = () => {
      try {
        const check = (tries = 0) => {
          const isGame = !!this._gameActive;
          let baitVisible = false;
          try {
            const el = this._bait?.el;
            if (el) {
              const cs = window.getComputedStyle(el);
              const rect = el.getBoundingClientRect();
              baitVisible = cs.display !== 'none' && cs.visibility !== 'hidden' && rect.width > 0 && rect.height > 0 && el.isConnected;
            }
          } catch(_) {}
          if (isGame && baitVisible) { this._showGameHud?.(); return; }
          if (tries > 60) { this._showGameHud?.(); return; } // ~1秒でフォールバック
          requestAnimationFrame(() => check(tries + 1));
        };
        check(0);
      } catch(_) { this._showGameHud?.(); }
    };
    // 初期は「動画画面」なので表示
    this._setBackVisible(true);

    // 動画エラーフォールバック
    const video = this.root.querySelector('#introVideo');
    // 動画の直後ろに黒背景を挿入（videoの直前に置く）
    const fishBgEl = this.root.querySelector('.fish-bg');
    this._videoBackdrop = document.createElement('div');
    this._videoBackdrop.className = 'video-backdrop';
    if (fishBgEl && video) fishBgEl.insertBefore(this._videoBackdrop, video);
    // 動画スケール（>1 でズームイン、<1 でズームアウト）
    const VIDEO_SCALE = 1.00; // 指定に合わせて等倍に戻す
    // 上端合わせ用の微調整オフセット（必要時に調整）
    const VIDEO_OFFSET_Y_PX = -120; // さらに上へ持ち上げ
    this._videoRatio = null;
    if (video) {
      // フルカバー（トリミング）で常に画面全体にフィット（縮小ではなくクロップ）
      Object.assign(video.style, {
        position: 'absolute', left: '0px', top: '0px', right: '0px', bottom: '0px', transform: 'none',
        width: '100%', height: '100%', objectFit: 'cover', objectPosition: 'center',
        // 下端を黒にフェード（黒下敷きとブレンド）
        WebkitMaskImage: 'linear-gradient(to bottom, rgba(255,255,255,1) 94%, rgba(255,255,255,0) 100%)',
        maskImage: 'linear-gradient(to bottom, rgba(255,255,255,1) 94%, rgba(255,255,255,0) 100%)',
        WebkitMaskSize: '100% 100%',
        maskSize: '100% 100%'
      });

    // 餌本体を少しだけ上方向へ持ち上げる（短い引き上げ演出）
    this._liftBaitShort = () => new Promise((resolve) => {
      try {
        const r = this._safe?.getBoundingClientRect();
        const bx = this._baitPosX ?? (()=>{ const br = this._bait?.getBounds?.(); return br? (br.left - r.left + br.width/2) : (r?.width??0)/2; })();
        const by = this._baitPosY ?? (()=>{ const br = this._bait?.getBounds?.(); return br? (br.top - r.top + br.height/2) : (r?.height??0)/2; })();
        const lift = Math.min((r?.height||240)*0.08, 48);
        const y0 = by; const y1 = Math.max(0, y0 - lift);
        const dur = 260; const start = performance.now();
        const step = (t)=>{
          const p = Math.min(1, (t - start)/dur); const ease = 1 - Math.pow(1-p,3);
          const y = y0 + (y1 - y0) * ease;
          try { this._bait?.setPosition?.(bx, y); } catch(_) {}
          this._baitPosX = bx; this._baitPosY = y; this._baitTargetX = bx; this._baitTargetY = y;
          if (p < 1) requestAnimationFrame(step); else resolve();
        };
        requestAnimationFrame(step);
      } catch(_) { resolve(); }
    });

    // 動画下端1pxを縦方向へストレッチして下敷きへ描画
    this._paintBlackBelowStrip = () => {
      try {
        const v = this._videoEl, c = this._blackBelowCanvas; if (!v || !c) return;
        const vw = v.videoWidth || 0, vh = v.videoHeight || 0; if (!vw || !vh) return;
        const ctx = c.getContext('2d', { willReadFrequently: true }); if (!ctx) return;
        // 1pxラインを全域に引き伸ばす
        ctx.imageSmoothingEnabled = false;
        ctx.clearRect(0, 0, c.width, c.height);
        ctx.drawImage(v, 0, vh - 1, vw, 1, 0, 0, c.width, c.height);
        // 最上段1行から平均色を算出（横方向平均）
        try {
          const row = ctx.getImageData(0, 0, c.width, 1).data;
          let r = 0, g = 0, b = 0, n = c.width;
          for (let i = 0; i < row.length; i += 4) { r += row[i]; g += row[i+1]; b += row[i+2]; }
          if (n > 0) {
            this._lastBottomColor = {
              r: Math.round(r / n),
              g: Math.round(g / n),
              b: Math.round(b / n)
            };
            // 任意: CSSカスタムプロパティにも反映
            this._layer?.style.setProperty('--video-bottom-color', `rgb(${this._lastBottomColor.r}, ${this._lastBottomColor.g}, ${this._lastBottomColor.b})`);
            // 動画の直後ろバックドロップに平均色を適用
            if (this._videoBackdrop) {
              const col = `rgb(${this._lastBottomColor.r}, ${this._lastBottomColor.g}, ${this._lastBottomColor.b})`;
              this._videoBackdrop.style.background = col;
              this._videoBackdrop.style.backgroundImage = 'none';
            }
          }
        } catch(_) {}
      } catch(_) { /* ignore */ }
    };

    // 起点（アンカー）方向へ一直線に引き上げて、yTopで止める
    this._pullBaitTowardAnchorLine = (durationMs = 180, yTop = -40) => new Promise((resolve) => {
      try {
        if (!this._safe || !this._bait) { resolve(); return; }
        const r = this._safe.getBoundingClientRect();
        // 現在位置
        const x0 = (this._baitPosX != null) ? this._baitPosX : Math.floor(r.width/2);
        const y0 = (this._baitPosY != null) ? this._baitPosY : Math.floor(r.height/2);
        // アンカー座標
        const ax = (this._ropeAnchorX == null) ? (r.width/2) : this._ropeAnchorX;
        const ay = (this._ropeAnchorY ?? -240);
        // 目標: 直線S->A上で y = yTop となる点
        let t = (yTop - y0) / ((ay - y0) || 1e-6);
        // 0..1にクランプ（異常時はフォールバックとして真上）
        if (!isFinite(t) || t <= 0 || t > 1.2) { this._pullBaitUpStraight?.(durationMs); setTimeout(resolve, durationMs); return; }
        const x1 = x0 + (ax - x0) * t;
        const y1 = yTop;
        const start = performance.now();
        const step = (tms) => {
          const p = Math.min(1, (tms - start) / Math.max(1, durationMs));
          const ease = 1 - Math.pow(1 - p, 3);
          const x = x0 + (x1 - x0) * ease;
          const y = y0 + (y1 - y0) * ease;
          this._baitPosX = x; this._baitTargetX = x;
          this._baitPosY = y; this._baitTargetY = y;
          this._bait.setPosition(x, y);
          if (p < 1) requestAnimationFrame(step); else resolve();
        };
        requestAnimationFrame(step);
      } catch(_) { resolve(); }
    });

    // ヒット直後の「一瞬下へ引っ張られる」演出
    this._tugBaitDown = (distancePx = 28, durationMs = 110) => new Promise((resolve) => {
      try {
        if (!this._safe || !this._bait) { resolve(); return; }
        const r = this._safe.getBoundingClientRect();
        const x0 = (this._baitPosX != null) ? this._baitPosX : Math.floor(r.width/2);
        const y0 = (this._baitPosY != null) ? this._baitPosY : Math.floor(r.height/2);
        const y1 = y0 + Math.max(6, distancePx);
        const start = performance.now();
        const step = (tms) => {
          const p = Math.min(1, (tms - start) / Math.max(1, durationMs));
          // easeOutCubic
          const ease = 1 - Math.pow(1 - p, 3);
          const y = y0 + (y1 - y0) * ease;
          this._baitPosX = x0; this._baitTargetX = x0;
          this._baitPosY = y; this._baitTargetY = y;
          this._bait.setPosition(x0, y);
          if (p < 1) requestAnimationFrame(step); else resolve();
        };
        requestAnimationFrame(step);
      } catch(_) { resolve(); }
    });

    // 糸を張って浮きを上昇させる簡易アニメ
    this._playTautAndFloatAnim = () => new Promise((resolve) => {
      try {
        // ロープを強めに、海流は抑制
        const prev = { it: this._ropeIters, dp: this._ropeDamp, cf: this._water?.currentForce };
        this._ropeIters = 20; this._ropeDamp = 0.9995;
        if (this._water) this._water.currentForce = 0;
        // 浮きを表示＆位置合わせ
        this._positionFloat?.();
        if (this._floatEl) this._floatEl.style.display = 'block';
        // 300msで浮きを上方向へ引き上げ
        const start = performance.now();
        const r = this._safe?.getBoundingClientRect();
        const y0 = this._floatEl ? parseFloat(this._floatEl.style.top||'6')||6 : 6;
        const lift = Math.min( (r?.height||240) * 0.08, 40 ); // 最大40px持ち上げ
        const dur = 320;
        const step = (t) => {
          const p = Math.min(1, (t - start) / dur);
          const ease = 1 - Math.pow(1 - p, 3);
          if (this._floatEl) this._floatEl.style.top = `${Math.max(-20, y0 - lift * ease)}px`;
          if (p < 1) {
            requestAnimationFrame(step);
          } else {
            // 値を戻す
            this._ropeIters = prev.it; this._ropeDamp = prev.dp;
            if (this._water) this._water.currentForce = prev.cf;
            // 浮きは少し間を置いて非表示
            setTimeout(()=>{ if (this._floatEl) this._floatEl.style.display = 'none'; resolve(); }, 80);
          }
        };
        requestAnimationFrame(step);
      } catch(_) { resolve(); }
    });

    // 公開: 動画最下ピクセル（横方向平均）の現在色を返す
    this.getVideoBottomAverageColor = () => {
      try {
        this._paintBlackBelowStrip?.();
        return this._lastBottomColor || null;
      } catch(_) { return null; }
    };
      this._onVideoMeta = () => {
        const vw = video.videoWidth || 16; const vh = video.videoHeight || 9;
        this._videoRatio = vw / vh;
        // メタデータ取得後に一度採色して適用
        this._paintBlackBelowStrip?.();
      };
      video.addEventListener('loadedmetadata', this._onVideoMeta);
    }
    // 動画アニメ用のオフセット（px）
    this._videoAnimY = 0;
    this._videoTriedAlt = false;
    this._awaitingRestart = false; // GET後の再スタート待ち
    this._lockBaitPos = false; // GET/引き上げ中は餌の慣性追従を止める
    this._skipPreTautFlow = false; // ヒット側で事前タイト演出を行った場合に _onGetFish 側をスキップ
    this._getPatternIdx = 0; // GETパターン/モードのローテーション用
    this.onVideoError = () => {
      // 一度だけ、同一パスで再試行（キャッシュや一時エラー回避）
      if (video && !this._videoTriedAlt) {
        this._videoTriedAlt = true;
        // MP4 へ明示フォールバック
        video.src = 'assets/turigamennsyoki.mp4';
        video.load();
        video.play?.().catch(() => {});
        return;
      }
      const warn = document.createElement('div');
      warn.className = 'small';
      warn.style.position = 'absolute';
      warn.style.left = '50%';
      warn.style.top = '50%';
      warn.style.transform = 'translate(-50%, -50%)';
      warn.style.background = 'rgba(0,0,0,0.35)';
      warn.style.padding = '8px 12px';
      warn.style.borderRadius = '8px';
      warn.textContent = '動画アセット（assets/turigamennsyoki.mp4）が見つからないか再生できません。';
      this.root.querySelector('.fish-layer').appendChild(warn);
    };
    if (video) {
      video.addEventListener('error', this.onVideoError);
      // 初期は自動再生（muted+autoplay 許可）
      video.muted = true;
      try { video.play?.(); } catch(_) {}
    }

    // フレーム: SVGマスクで中央をくり抜く（16:9）
    const layer = this.root.querySelector('.fish-layer');
    const svgHost = this.root.querySelector('.frame-svg');
    svgHost.style.visibility = 'hidden';
    svgHost.innerHTML = `
      <svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" preserveAspectRatio="none">
        <defs>
          <mask id="df-fish-mask" maskUnits="userSpaceOnUse" x="0" y="0" width="100%" height="100%">
            <rect x="0" y="0" width="100%" height="100%" fill="white"/>
            <rect id="df-fish-hole" x="0" y="0" width="0" height="0" fill="black"/>
          </mask>
        </defs>
        <image id="df-fish-frame" x="0" y="0" width="100%" height="100%" href="assets/frame1.webp" preserveAspectRatio="xMidYMid slice" mask="url(#df-fish-mask)"/>
      </svg>
    `;
    // frame1.webp が無い環境では png にフォールバック
    try {
      const frameImgEl = svgHost.querySelector('#df-fish-frame');
      const probe = new Image();
      probe.onload = () => {};
      probe.onerror = () => { try { frameImgEl?.setAttribute('href', 'assets/frame1.png'); } catch(_) {} };
      probe.src = 'assets/frame1.webp';
    } catch(_) {}

    const safe = this.root.querySelector('.safe-viewport');
    // 参照を保持（unmount用）
    this._layer = layer;
    this._safe = safe;
    this._videoEl = video;
    this._gameActive = false; // ゲーム進行中（当たり判定ON）

    // TAPガイド（投げる前の点滅）
    this._tapGuideEl = document.createElement('img');
    this._tapGuideEl.className = 'tap-guide';
    this._tapGuideEl.decoding = 'async';
    this._tapGuideEl.alt = 'TAP';
    this._tapGuideEl.onerror = () => {
      if (this._tapGuideEl && this._tapGuideEl.src.endsWith('.webp')) {
        this._tapGuideEl.onerror = null; this._tapGuideEl.src = 'assets/TAP.png';
      }
    };
    this._tapGuideEl.src = 'assets/TAP.webp';
    if (this._safe) this._safe.appendChild(this._tapGuideEl);
    try { this._tapGuideEl.style.display = 'none'; } catch(_) {}
    this._showTapGuide = () => { try { if (this._tapGuideEl) this._tapGuideEl.style.display = ''; } catch(_) {} };
    this._hideTapGuide = () => { try { if (this._tapGuideEl) this._tapGuideEl.style.display = 'none'; } catch(_) {} };

    // 付加レイヤー準備
    // 動画のすぐ下を黒で埋める下敷き
    this._blackBelow = document.createElement('div');
    this._blackBelow.className = 'black-below';
    layer.appendChild(this._blackBelow);
    // 下敷き描画用キャンバス（ボトムピクセル拡張）
    this._blackBelowCanvas = document.createElement('canvas');
    this._blackBelowCanvas.className = 'black-below-canvas';
    Object.assign(this._blackBelowCanvas.style, { display:'block', width:'100%', height:'100%' });
    this._blackBelow.appendChild(this._blackBelowCanvas);
    // フェード（黒）
    this._fade = document.createElement('div');
    this._fade.className = 'fade-overlay';
    layer.appendChild(this._fade);
    try { this._fade.style.display = 'none'; } catch(_) {}
    // バブルキャンバス
    this._bubbleCanvas = document.createElement('canvas');
    this._bubbleCanvas.className = 'bubble-canvas';
    layer.appendChild(this._bubbleCanvas);
    // セーフエリア内スクロール背景（ゲーム画面）
    // 先に黒背景レイヤー（黒画像相当）
    this._gameBlackBg = document.createElement('div');
    this._gameBlackBg.className = 'game-bg-black';
    safe.appendChild(this._gameBlackBg);
    this._scrollBg = document.createElement('div');
    this._scrollBg.className = 'game-scroll';
    safe.insertBefore(this._scrollBg, safe.firstChild);
    // スクロール画像の縦横比（高さ/幅）を取得
    this._scrollRatioHPerW = null;
    const _scrollImg = new Image();
    _scrollImg.onload = () => {
      this._scrollRatioHPerW = _scrollImg.naturalHeight / _scrollImg.naturalWidth;
      // レイアウトに反映
      if (typeof updateMaskHole === 'function') updateMaskHole();
    };
    _scrollImg.src = 'assets/game_start_2.png';
    this._scrollProbe = _scrollImg;
    // 餌（Baitオブジェクト）: 従来通りランプ餌（マウス追従用の見た目）
    this._bait = new Bait({
      parent: safe,
      initialType: { id: 'lampbait', name: 'ランプ餌', rank: 0, src: 'assets/lampbait.png' }
    });
    this._bait.mount();
    // 餌を発光させる（ランプ系の柔らかい光）
    try { this._bait?.el?.classList?.add('glow'); } catch(_) {}
    // 糸（ロープ）キャンバス（餌の下に配置）
    this._ropeCanvas = document.createElement('canvas');
    this._ropeCanvas.className = 'rope-canvas';
    Object.assign(this._ropeCanvas.style, { position:'absolute', inset:'0', zIndex:'6', pointerEvents:'none', display:'none' });
    this._ropeEnabled = false; // 動画中は表示しない
    this._ropeAnchorY = -240; // 起点をさらに上（画面外）へ
    this._ropeAnchorX = null; // null=自動的にセーフ中央
    if (this._bait?.el?.parentNode) this._bait.el.parentNode.insertBefore(this._ropeCanvas, this._bait.el);
    // 浮き（上端付近に表示、通常は非表示）
    this._initFloat = () => {
      if (!this._safe) return;
      if (this._floatEl) return;
      const f = document.createElement('div');
      f.className = 'float-bob';
      f.style.display = 'none';
      this._safe.appendChild(f);
      this._floatEl = f;
      this._positionFloat?.();
    };
    this._positionFloat = () => {
      if (!this._floatEl || !this._safe) return;
      const r = this._safe.getBoundingClientRect();
      const x = Math.floor(r.width/2);
      this._floatEl.style.left = `${x}px`;
      this._floatEl.style.top = `6px`;
    };
    // 海水パラメータ（浮力・海流・うねり）
    this._water = {
      // 浮力（0..1）: 値が大きいほど有効重力が小さくなる
      buoyancy: 0.9,
      // 横方向の海流: 振幅/周波数/位相速度
      currentForce: 160,
      currentFreq: 0.18,
      currentPhaseSpeed: 0.7,
      // 縦方向のうねり（浮力に乗る上下動の加速度成分）
      swellForce: 200,
      swellFreq: 0.4
    };
    // ロープ剛性（可変）
    this._ropeDamp = 0.998;
    this._ropeIters = 10;
    this._waterPhase = 0;
    // デバッグ: ヒットボックス可視化キャンバス
    if (this.root.classList.contains('debug-colliders')) {
      this._hitboxCanvas = document.createElement('canvas');
      this._hitboxCanvas.className = 'hitbox-canvas';
      this._hitboxCanvas.style.position = 'absolute';
      this._hitboxCanvas.style.inset = '0';
      this._hitboxCanvas.style.zIndex = '7';
      this._hitboxCanvas.style.pointerEvents = 'none';
      safe.appendChild(this._hitboxCanvas);
    }
    // マウス慣性追従
    this._baitFollowAlpha = 0.2; // 0..1 大きいほど速く追従
    this._baitTargetX = null; this._baitTargetY = null;
    this._baitPosX = null; this._baitPosY = null;
    // マウス（ポインタ）追従
    this._onPointerMove = (ev) => {
      if (!this._safe || !this._bait?.setPosition) return;
      // GET中・ロック中はポインタ追従を停止（真上に引き上げを維持）
      if (this._handlingGet || this._lockBaitPos) return;
      const r = this._safe.getBoundingClientRect();
      const x = Math.max(0, Math.min(ev.clientX - r.left, r.width));
      const y = Math.max(0, Math.min(ev.clientY - r.top, r.height));
      this._baitTargetX = x; this._baitTargetY = y;
      // 初回はワープ
      if (this._baitPosX == null || this._baitPosY == null) {
        this._baitPosX = x; this._baitPosY = y;
        this._bait.setPosition(x, y);
      }
    };
    // 上部UI帯（.fish-topbar）上でも追従させるため、レイヤーにバインド
    layer.addEventListener('pointermove', this._onPointerMove);
    layer.addEventListener('pointerdown', this._onPointerMove);
    // 慣性ループ
    this._baitFollowStep = (t) => {
      const now = t || performance.now();
      const last = this._lastBaitFollowT || now; this._lastBaitFollowT = now;
      const dt = Math.min(0.05, Math.max(0.001, (now - last) / 1000));
      // GET中/ロック中/ゲーム非アクティブ時は慣性追従を停止
      if (!(this._handlingGet || this._lockBaitPos || !this._gameActive)) {
        if (this._baitTargetX != null && this._baitTargetY != null && this._baitPosX != null && this._baitPosY != null) {
          const a = this._baitFollowAlpha;
          this._baitPosX += (this._baitTargetX - this._baitPosX) * a;
          this._baitPosY += (this._baitTargetY - this._baitPosY) * a;
          this._bait.setPosition(this._baitPosX, this._baitPosY);
        }
      }
      // ロープ更新・描画
      this._updateRope?.(dt);
      this._drawRope?.();
      this._baitFollowRaf = requestAnimationFrame(this._baitFollowStep);
    };
    this._baitFollowRaf = requestAnimationFrame(this._baitFollowStep);
    // 魚データ読み込み（ローマ字ID、ランク、ムーブプリセット）
    this._fishData = null;
    this._movementPresets = null;
    this._loadFishData = async () => {
      try {
        // タイトル側プリロードを優先
        const pre = (typeof window !== 'undefined' && window.__df_preloads && window.__df_preloads.fishData) ? window.__df_preloads.fishData : null;
        let data = pre;
        if (!data) {
          const res = await fetch('src/data/fish.json', { cache: 'no-store' });
          if (!res.ok) throw new Error('fish.json load failed');
          data = await res.json();
        }
        this._fishData = data?.fish || [];
        this._movementPresets = data?.movementPresets || {};
        // baitTypes から ebi を優先適用（sprite→src マッピング）。無ければ現状維持
        const toType = (b) => b ? ({ id: b.id, name: b.name_ja || b.id, rank: Number(b.rank || 0), src: b.src || b.sprite }) : null;
        const ebi = (data?.baitTypes || []).find(b => b.id === 'ebi');
        const first = (data?.baitTypes || [])[0];
        const chosen = toType(ebi) || toType(first);
        if (chosen) {
          // マウス追従の餌見た目は変更しない。
          // 餌箱を更新するのは START（新規）時のみ。CONTINUE はセーブの餌を優先。
          if (this._mode === 'start') this._setEsabakoSprite?.(chosen.src, chosen.name);
        }
      } catch (e) { console.warn('fish.json load error', e); }
    };
    const hole = svgHost.querySelector('#df-fish-hole');
    const maskEl = svgHost.querySelector('#df-fish-mask');
    const R = 16/9;
    const SAFE_SCALE = 0.80; // 釣り専用: 左右のみ0.80、縦はフル
    const updateMaskHole = () => {
      if (!layer || !safe || !hole) return;
      const lr = layer.getBoundingClientRect();
      const Lw = lr.width, Lh = lr.height;
      let w = Math.min(Lw, Lh * R);
      let h = Math.min(Lh, Lw / R);
      if (w / h > R) w = h * R; else h = w / R;
      // タイトルと同一: 少し小さく（背景/動画より穴を基準に）
      w *= SAFE_SCALE;
      h *= SAFE_SCALE;
      const x = (Lw - w) / 2;
      const y = (Lh - h) / 2;
      // サブピクセル差の低減（整数丸め）
      const rx = Math.round(x), ry = Math.round(y), rw = Math.round(w), rh = Math.round(h);

      // 穴は16:9基準を横幅に採用しつつ、縦は上下フル（釣りのみ上下フレーム非表示）
      hole.setAttribute('x', String(rx));
      hole.setAttribute('y', '0');
      hole.setAttribute('width', String(rw));
      hole.setAttribute('height', String(Lh));
      if (maskEl) {
        maskEl.setAttribute('x', '0');
        maskEl.setAttribute('y', '0');
        maskEl.setAttribute('width', String(Lw));
        maskEl.setAttribute('height', String(Lh));
      }
      // UIセーフエリアも縦フルに（左右は0.80の幅、上下はフル）
      const uiW = rw;
      const uiH = Math.round(Lh);
      const uiX = rx;
      const uiY = 0;
      Object.assign(safe.style, {
        position: 'absolute', left: `${uiX}px`, top: `${uiY}px`, width: `${uiW}px`, height: `${uiH}px`
      });
      // トップバーをセーフエリアに追従配置（フレーム外に押し出されて見切れないように）
      try {
        const topbar = this.root.querySelector('.fish-topbar');
        if (topbar) {
          topbar.style.left = `${uiX + 4}px`;
          topbar.style.top = `${uiY + 6 + UI_OFFSET_Y_PX}px`;
          topbar.style.width = `${Math.max(0, uiW - 8)}px`;
          topbar.style.right = 'auto';
          topbar.style.position = 'absolute';
          topbar.style.zIndex = '12';
          topbar.style.overflow = 'visible';
        }
        this._fitTopset?.();
      } catch(_) {}

      // スクロール背景のタイル高さを計算（横幅100%に拡大するため、tileH = 幅 * (imgH/imgW)）
      if (this._scrollBg) {
        const ratioHPW = this._scrollRatioHPerW || 1; // デフォルト1:1
        this._tileH = Math.max(1, Math.floor(uiW * ratioHPW));
        // CSSアニメは無効化（JSでループ制御）
        this._scrollBg.style.animation = 'none';
        this._scrollBg.style.backgroundSize = '100% auto';
        this._scrollBg.style.backgroundRepeat = 'repeat-y';
      }

      // 動画の見せ方: 穴幅(uiW)を基準に VIDEO_SCALE 倍で縮小（縦は黒下敷きで補完）
      if (video) {
        // 穴の横幅を基準にし、上下は黒下敷きで補完
        const ratio = this._videoRatio || (16/9);
        const needWBase = uiW;
        const needW = Math.max(1, Math.floor(needWBase * VIDEO_SCALE));
        video.style.width = `${needW}px`;
        video.style.height = 'auto';
        // 上端をフレーム（セーフエリア）上端に合わせ、水平はセーフエリア中央
        const centerX = Lw / 2;
        const topY = uiY + VIDEO_OFFSET_Y_PX;
        video.style.left = `${centerX}px`;
        video.style.top = `${topY}px`;
        video.style.transform = `translate(-50%, ${this._videoAnimY || 0}px)`;
        // 黒下敷きを動画の下端から下方向に敷く（移動は transform で同期）
        if (this._blackBelow) {
          const ratio = this._videoRatio || (16/9);
          const needH = Math.floor(needW / ratio);
          const baseTop = topY; // アニメオフセットは transform で適用
          const belowTop = Math.floor(baseTop + needH);
          const lr = layer.getBoundingClientRect();
          const Lh = lr.height;
          const hPx = Math.max(0, Math.floor(Lh - belowTop));
          Object.assign(this._blackBelow.style, {
            position: 'absolute', left: `${uiX}px`, width: `${uiW}px`, top: `${belowTop}px`, height: `${hPx}px`, background: '#000', zIndex: '0'
          });
          // キャンバス実サイズを更新
          const dpr = Math.max(1, window.devicePixelRatio || 1);
          if (this._blackBelowCanvas) {
            const cw = Math.max(1, Math.floor(uiW * dpr));
            const ch = Math.max(1, Math.floor(hPx * dpr));
            if (this._blackBelowCanvas.width !== cw) this._blackBelowCanvas.width = cw;
            if (this._blackBelowCanvas.height !== ch) this._blackBelowCanvas.height = ch;
            // 動画最下1pxを縦にストレッチ
            this._paintBlackBelowStrip?.();
          }
        }
      }
    };
    this._onResize = () => { updateMaskHole(); this._initRope?.(); this._positionFloat?.(); };
    window.addEventListener('resize', this._onResize);
    if (typeof ResizeObserver !== 'undefined') {
      this._ro = new ResizeObserver(() => updateMaskHole());
      this._ro.observe(layer);
      this._ro.observe(safe);
    }
    const afterLayout = () => {
      updateMaskHole(); this._paintBlackBelowStrip?.(); svgHost.style.visibility = 'visible';
      // 初期: 動画画面の現在水深を0mで明示
      try { this._totalScrollPx = 0; this._depthMeters = 0; this._renderDepth?.(); } catch(_) {}
      // トップセット表示
      this._spawnEsabakoMini?.();
      this._animateTopSet?.();
      this._fitTopset?.();
      this._installTopsetObservers?.();
      // 保存されているエサ情報をUIへ反映（論理のみ＋右上の餌箱）
      try {
        if (this._mode === 'start') {
          // スタート時はエビから（見た目はPLUSのまま、論理のみ）
          SaveManager.setBait?.(this.state, 'ebi', 0);
          this._bait?.setLogicalRank?.(0, 'ebi');
        } else {
          const b = this.state?.bait; if (b) { this._bait?.setLogicalRank?.(b.rank, b.id); }
          // 続きからは餌箱も前回の餌（=前回GET魚）に合わせる
          const id = b?.id; if (id) this._setEsabakoById?.(id);
        }
      } catch(_) {}
      this._loadFishData?.(); this._initRope?.(); this._initFloat?.();
      this._showTapGuide?.();
      // 直後にもう一度レイアウト確定後の位置合わせを実行（初回表示時のズレ防止）
      requestAnimationFrame(() => { try { updateMaskHole(); } catch(_) {} });
      // 可変幅フォント等のロード完了後にも再度合わせる（フォント計測差分対策）
      try { if (document.fonts && document.fonts.ready) { document.fonts.ready.then(() => { try { updateMaskHole(); } catch(_) {} }); } } catch(_) {}
    };
    requestAnimationFrame(() => requestAnimationFrame(afterLayout));

    // タップでシーケンス起動
    this._seqStarted = false;
    this._applyVideoAnim = (y) => {
      this._videoAnimY = y;
      if (this._videoEl) {
        this._videoEl.style.transform = `translate(-50%, ${y}px)`;
      }
      if (this._blackBelow) {
        this._blackBelow.style.transform = `translateY(${y}px)`;
      }
    };
    // 動画を上から元位置(0px)へスライドさせる
    this._playVideoSlideFromTop = (durationMs = 800, startOffsetPx = -100) => new Promise((resolve) => {
      try {
        // 初期オフセットを適用
        this._applyVideoAnim?.(startOffsetPx);
        const start = performance.now();
        const y0 = startOffsetPx, y1 = 0;
        const step = (t) => {
          const p = Math.min(1, (t - start) / durationMs);
          const ease = 1 - Math.pow(1 - p, 3);
          const y = y0 + (y1 - y0) * ease;
          this._applyVideoAnim?.(y);
          if (p < 1) requestAnimationFrame(step); else resolve();
        };
        requestAnimationFrame(step);
      } catch(_) { resolve(); }
    });
    this._startVideoBounceAndAscend = () => new Promise((resolve) => {
      const downDur = 160; // ms
      const yDown = 22; // px
      const upAcc = -0.004; // px/ms^2（上向き加速）
      const upV0 = -0.20; // px/ms（初速）
      // 目標オフセット: 動画の下端がレイヤー上端よりさらに上になるまで（= 完全に画面外）
      let endY = -600; // フォールバック
      try {
        const ratio = this._videoRatio || (16/9);
        // スタイルから表示幅を取得（未設定時はセーフエリアから推定）
        let vidW = parseFloat(this._videoEl?.style.width || '0') || 0;
        if (!vidW && this._safe) {
          const r = this._safe.getBoundingClientRect();
          const baseW = Math.max(r.width, r.height * ratio);
          vidW = baseW * (typeof VIDEO_SCALE !== 'undefined' ? VIDEO_SCALE : 1);
        }
        if (vidW > 0) {
          const vidH = vidW / ratio;
          const topY = parseFloat(this._videoEl?.style.top || '0') || 0;
          endY = -(topY + vidH) - 8; // 余白8pxで完全に抜ける
        }
      } catch (_) {}
      let start = 0;
      const step = (t) => {
        if (!start) start = t;
        const dt = t - start;
        let y = 0;
        if (dt <= downDur) {
          const p = dt / downDur; // easeOutCubic
          y = yDown * (1 - Math.pow(1 - p, 3));
        } else {
          const t2 = dt - downDur;
          y = yDown + upV0 * t2 + 0.5 * upAcc * t2 * t2;
          if (y <= endY) {
            this._applyVideoAnim(endY);
            resolve();
            return;
          }
        }
        this._applyVideoAnim(y);
        this._animRaf = requestAnimationFrame(step);
      };
      this._animRaf = requestAnimationFrame(step);
    });

    this._startBubbles = (durationMs = 1000) => new Promise((resolve) => {
      // キャンバスが消されていた場合は再生成
      if (!this._bubbleCanvas) {
        this._bubbleCanvas = document.createElement('canvas');
        this._bubbleCanvas.className = 'bubble-canvas';
        this._layer?.appendChild(this._bubbleCanvas);
      }
      const cvs = this._bubbleCanvas;
      const ctx = cvs.getContext('2d');
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const fit = () => {
        const r = layer.getBoundingClientRect();
        cvs.width = Math.max(1, Math.floor(r.width * dpr));
        cvs.height = Math.max(1, Math.floor(r.height * dpr));
        cvs.style.width = r.width + 'px';
        cvs.style.height = r.height + 'px';
      };
      fit();
      let bubbles = [];
      const spawn = (n) => {
        const rw = cvs.width, rh = cvs.height;
        for (let i = 0; i < n; i++) {
          // 大小混在：80%は小粒 3..6px、20%は大粒 8..12px（CSS px相当）
          const big = Math.random() < 0.2;
          const sizeCss = big ? (8 + Math.floor(Math.random() * 5)) : (3 + Math.floor(Math.random() * 4));
          const s = sizeCss * dpr; // デバイスpxに変換
          const x = Math.floor(Math.random() * rw);
          const y = rh + Math.floor(Math.random() * (50 * dpr));
          const vy = -(0.22 + Math.random() * 0.50) * dpr; // px/ms（上方向）: 以前より高速
          bubbles.push({ x, y, s, vy });
        }
      };
      // 初期大量スポーン
      spawn(400);
      let last = performance.now();
      let elapsed = 0;
      const run = (t) => {
        const dt = t - last; last = t; elapsed += dt;
        // 追加スポーンで画面を覆っていく
        if (elapsed < durationMs) {
          spawn(60);
        }
        ctx.clearRect(0, 0, cvs.width, cvs.height);
        ctx.imageSmoothingEnabled = false;
        ctx.fillStyle = '#9fdcf9';
        for (let i = bubbles.length - 1; i >= 0; i--) {
          const b = bubbles[i];
          b.y += b.vy * dt;
          // ドット描画
          ctx.fillRect(b.x, b.y, b.s, b.s);
          if (b.y < -10 * dpr) bubbles.splice(i, 1);
        }
        this._bubbleRaf = requestAnimationFrame(run);
      };
      this._bubbleRaf = requestAnimationFrame(run);
      // 指定時間後に次へ
      this._bubbleTimer = setTimeout(() => resolve(), durationMs);
      this._onResizeBubbles = () => fit();
      window.addEventListener('resize', this._onResizeBubbles);
    });

    this._stopBubbles = () => {
      if (this._bubbleRaf) cancelAnimationFrame(this._bubbleRaf);
      this._bubbleRaf = null;
      if (this._bubbleTimer) { clearTimeout(this._bubbleTimer); this._bubbleTimer = null; }
      if (this._onResizeBubbles) window.removeEventListener('resize', this._onResizeBubbles);
      if (this._bubbleCanvas) this._bubbleCanvas.remove();
      this._bubbleCanvas = null;
    };

    // 即時に餌を画面上部外へ移動させる（ヒット直後の見た目用）
    this._forceBaitOffscreenTop = () => {
      try {
        if (!this._safe || !this._bait) return;
        const r = this._safe.getBoundingClientRect();
        // 現在位置（なければ中心）
        const bx = (this._baitPosX != null) ? this._baitPosX : Math.floor(r.width/2);
        const yTop = -40; // 画面上部外
        this._baitPosX = bx; this._baitPosY = yTop;
        this._baitTargetX = bx; this._baitTargetY = yTop;
        this._bait.setPosition(bx, yTop);
      } catch(_) {}
    };

    // 真上にのみ素早く引き上げる（X固定）
    this._pullBaitUpStraight = (durationMs = 160) => {
      try {
        if (!this._safe || !this._bait) return;
        const r = this._safe.getBoundingClientRect();
        const bx = (this._baitPosX != null) ? this._baitPosX : Math.floor(r.width/2);
        const by = (this._baitPosY != null) ? this._baitPosY : Math.floor(r.height/2);
        const y1 = -40;
        const y0 = by;
        const start = performance.now();
        const step = (t) => {
          const p = Math.min(1, (t - start) / Math.max(1, durationMs));
          const ease = 1 - Math.pow(1 - p, 3);
          const y = y0 + (y1 - y0) * ease;
          this._baitPosX = bx; this._baitPosY = y;
          this._baitTargetX = bx; this._baitTargetY = y;
          this._bait.setPosition(bx, y);
          if (p < 1) requestAnimationFrame(step);
        };
        requestAnimationFrame(step);
      } catch(_) {}
    };

    // ロープの起点（アンカーY）を素早く上へ移動してピンと張る
    this._animRopeAnchorTo = (targetY, durationMs = 160) => new Promise((resolve) => {
      try {
        const startY = this._ropeAnchorY ?? -30;
        const start = performance.now();
        const step = (t) => {
          const p = Math.min(1, (t - start) / durationMs);
          const ease = 1 - Math.pow(1 - p, 3);
          this._ropeAnchorY = startY + (targetY - startY) * ease;
          if (p < 1) requestAnimationFrame(step); else resolve();
        };
        requestAnimationFrame(step);
      } catch(_) { resolve(); }
    });

    // フェード汎用: transitionend が来ない場合に備えてタイムアウトを入れる
    this._fadeTo = (to = 0, timeoutMs = 900) => new Promise((resolve) => {
      if (!this._fade) { resolve(); return; }
      let done = false; let timer = null;
      const onEnd = () => { if (done) return; done = true; try { this._fade.removeEventListener('transitionend', onEnd); } catch(_) {}; if (timer) clearTimeout(timer); resolve(); };
      try { this._fade.addEventListener('transitionend', onEnd); } catch(_) {}
      try { timer = setTimeout(onEnd, timeoutMs); } catch(_) {}
      requestAnimationFrame(()=>{ this._fade.style.opacity = String(to); });
    });
    // 表示/非表示を伴うフェード
    this._showBlack = (timeoutMs = 900) => { try { this._fade.style.display = 'block'; } catch(_) {}; return this._fadeTo(1, timeoutMs); };
    this._hideBlack = (timeoutMs = 900) => this._fadeTo(0, timeoutMs).then(()=>{ try { this._fade.style.display = 'none'; } catch(_) {} });
    this._fadeInBlack = () => this._showBlack();

    // 動画の先頭フレームが描画可能になるのを待つ（最大timeoutMs）
    this._waitForVideoReady = (timeoutMs = 800) => new Promise((resolve) => {
      const v = this._videoEl; if (!v) { resolve(); return; }
      try {
        if ((v.readyState || 0) >= 2) { resolve(); return; } // HAVE_CURRENT_DATA
      } catch(_) {}
      let to = null;
      const done = () => { try { v.removeEventListener('canplay', onCanPlay); } catch(_) {}; if (to) clearTimeout(to); resolve(); };
      const onCanPlay = () => done();
      try { v.addEventListener('canplay', onCanPlay, { once: true }); } catch(_) {}
      try { to = setTimeout(done, timeoutMs); } catch(_) {}
    });

    // 動画が黒フレームのままにならないよう、わずかに先頭をシークして再生を確実にする
    this._ensureVideoVisible = async () => {
      const v = this._videoEl; if (!v) return;
      try {
        v.muted = true; v.playsInline = true; v.autoplay = true;
        // 先頭フレームで黒い場合があるため、わずかに進める
        try { if ((v.currentTime || 0) < 0.05) v.currentTime = 0.05; } catch(_) {}
        try { await v.play?.(); } catch(_) {}
        await new Promise((resolve) => {
          let to = null; const cleanup = () => { try { v.removeEventListener('timeupdate', onReady); v.removeEventListener('canplay', onReady); } catch(_) {}; if (to) clearTimeout(to); };
          const onReady = () => { cleanup(); resolve(); };
          try { v.addEventListener('timeupdate', onReady, { once: true }); } catch(_) {}
          try { v.addEventListener('canplay', onReady, { once: true }); } catch(_) {}
          to = setTimeout(()=>{ cleanup(); resolve(); }, 800);
        });
      } catch(_) {}
    };

    this._showBait = () => new Promise((resolve) => {
      try { this._setBackVisible?.(false); this._bait?.show?.(); } catch(_) {}
      setTimeout(resolve, 400);
    });

    this._switchToGameScroll = () => {
      this._hideTapGuide?.();
      // 釣り開始（ゲーム画面）では「タイトルへ」非表示
      this._setBackVisible?.(false);
      // 背景を切替（動画は停止・非表示）
      try { this._videoEl?.pause(); } catch(_) {}
      if (this._videoEl) this._videoEl.style.display = 'none';
      if (this._gameBlackBg) this._gameBlackBg.style.display = 'block';
      if (this._scrollBg) this._scrollBg.style.display = 'block';
      if (this._blackBelow) this._blackBelow.style.display = 'none';
      // バブル終了
      this._stopBubbles();
      // 黒フェードを戻して表示
      requestAnimationFrame(() => { this._fade.style.opacity = '0'; });
      // スクロール開始
      this._initFishSystem?.();
      this._startScrollBg?.();
      // ロープ有効化（動画画面では表示しないためここでON）
      this._ropeEnabled = true;
      if (this._ropeCanvas) this._ropeCanvas.style.display = 'block';
      this._initRope?.();
      this._resetRopeAnchorXToCenter?.();
      // トップセットは非表示のまま、餌の可視化を待ってからHUDを出す
      this._showHudWhenBaitVisible?.();
      this._gameActive = true;
      // GET中にロックした餌の慣性追従を解除
      this._lockBaitPos = false;
    };

    // 餌の位置を中央へリセット
    this._resetBaitToCenter = () => {
      try {
        if (!this._safe || !this._bait) return;
        const r = this._safe.getBoundingClientRect();
        const cx = Math.floor(r.width / 2);
        const cy = Math.floor(r.height / 2);
        this._baitTargetX = cx; this._baitTargetY = cy;
        this._baitPosX = cx; this._baitPosY = cy;
        this._bait.setPosition(cx, cy);
      } catch(_) {}
    };

    this._runFishingIntroSequence = async () => {
      // 動画モードを明示的に復帰
      if (this._videoEl) {
        this._videoEl.style.display = 'block';
        try { this._videoEl.play?.(); } catch(_) {}
      }
      // 動画画面では現在水深を0mにリセットして表示
      try { this._totalScrollPx = 0; this._depthMeters = 0; this._renderDepth?.(); } catch(_) {}
      // タップ直後: トップセットを引き上げて非表示、HUDも隠す
      try {
        this._hideTopset?.();
        const hud = this.root.querySelector('#gameHud');
        if (hud) hud.style.display = 'none';
      } catch(_) {}
      if (this._gameBlackBg) this._gameBlackBg.style.display = 'none';
      if (this._scrollBg) this._scrollBg.style.display = 'none';
      if (this._blackBelow) this._blackBelow.style.display = 'block';
      // フェードを消す（display:noneまで）
      try { await this._hideBlack(0); } catch(_) {}
      // 餌の位置を中央にリセット
      this._resetBaitToCenter?.();
      // まずボトムピクセル拡張の下敷きを描画
      this._paintBlackBelowStrip();
      await this._startVideoBounceAndAscend();
      await this._fadeInBlack();
      // 餌を並行で出す
      this._showBait();
      // 1.5秒だけ泡を出したら切替
      await this._startBubbles(1500);
      this._switchToGameScroll();
    };

    this._onTap = (e) => {
      // 「タイトルへ」ボタンだけは無視し、それ以外のトップバー上クリックは許可
      if (e?.target && e.target.closest('#btnBack')) return;
      if (this._seqStarted) return;
      if (this._handlingGet) return; // GET処理中は入力無視
      // GET表示中/ワイプ中/釣れた魚表示中/GETバッジ表示中/バックドロップ表示中は割り込み禁止（自動復帰に任せる）
      try { if (this._layer?.querySelector?.('.get-overlay,.wipe-overlay,.caught-fish-overlay,.get-badge-overlay,.get-backdrop-overlay,.get-backdrop-canvas')) return; } catch(_) {}
      // TAPガイドを隠す
      this._hideTapGuide?.();
      if (this._awaitingRestart) {
        // GET後の再スタート
        try { this._layer?.querySelectorAll?.('.get-overlay,.wipe-overlay,.caught-fish-overlay,.get-badge-overlay,.get-backdrop-overlay,.get-backdrop-canvas')?.forEach(el=>el.remove()); } catch(_) {}
        this._awaitingRestart = false;
        try { this._videoEl?.play?.(); } catch(_) {}
        this._seqStarted = true;
        this._runFishingIntroSequence();
        return;
      }
      // 初回スタート
      try { this._layer?.querySelectorAll?.('.get-overlay,.wipe-overlay,.caught-fish-overlay,.get-badge-overlay,.get-backdrop-overlay,.get-backdrop-canvas')?.forEach(el=>el.remove()); } catch(_) {}
      this._seqStarted = true;
      this._runFishingIntroSequence();
    };
    layer.addEventListener('pointerdown', this._onTap);

    // 背景スクロールループ（rAF）
    // スクロール速度倍率（加速用）
    this._scrollSpeedMul = 1;
    this._speedBoostTimer = null;
    this._speedFxRaf = null;
    this._speedFxCanvas = null;
    this.applySpeedBoost = (mul = 2, durationMs = 2000) => {
      try { if (this._speedBoostTimer) clearTimeout(this._speedBoostTimer); } catch(_) {}
      this._scrollSpeedMul = Math.max(0.1, mul);
      // 視覚演出（白いスピードストリーク）開始
      this._startSpeedStreaks?.();
      this._speedBoostTimer = setTimeout(() => {
        this._scrollSpeedMul = 1;
        this._speedBoostTimer = null;
        // 視覚演出終了
        this._stopSpeedStreaks?.();
      }, durationMs);
    };

    // 加速演出: 白い線が上方向に走るスピードストリーク
    this._startSpeedStreaks = () => {
      try {
        if (!this._safe) return;
        if (!this._speedFxCanvas) {
          const cvs = document.createElement('canvas');
          cvs.className = 'speed-streaks';
          cvs.style.position = 'absolute';
          cvs.style.inset = '0';
          cvs.style.pointerEvents = 'none';
          cvs.style.zIndex = '8';
          this._safe.appendChild(cvs);
          this._speedFxCanvas = cvs;
          const resize = () => {
            try {
              const r = this._safe.getBoundingClientRect();
              const dpr = Math.max(1, window.devicePixelRatio || 1);
              cvs.width = Math.max(1, Math.floor(r.width * dpr));
              cvs.height = Math.max(1, Math.floor(r.height * dpr));
              cvs.style.width = r.width + 'px';
              cvs.style.height = r.height + 'px';
            } catch(_) {}
          };
          this._onResizeSpeedFx = resize;
          resize();
          try { window.addEventListener('resize', this._onResizeSpeedFx); } catch(_) {}
        }
        if (!this._speedFxRaf && this._speedFxCanvas) {
          const ctx = this._speedFxCanvas.getContext('2d');
          if (!ctx) return;
          const streaks = [];
          let last = performance.now();
          const step = (t) => {
            const dt = (t - last) / 1000; last = t;
            const cvs = this._speedFxCanvas;
            if (!cvs) { this._speedFxRaf = null; return; }
            const dpr = Math.max(1, window.devicePixelRatio || 1);
            const w = cvs.width, h = cvs.height;
            ctx.clearRect(0, 0, w, h);
            // ブースト倍率に応じた生成・速度
            const mul = Math.max(1, this._scrollSpeedMul || 1);
            const spawn = Math.min(200, Math.floor(10 * mul));
            for (let i = 0; i < spawn; i++) {
              streaks.push({
                x: Math.random() * w,
                y: h + Math.random() * h * 0.3,
                len: (10 + Math.random() * 50) * dpr * Math.min(1.5, mul * 0.2),
                vy: (-400 - Math.random() * 900) * (0.5 + (mul - 1) * 0.25),
                a: 0.15 + Math.random() * 0.25,
                w: Math.max(1, Math.floor((1 + Math.random() * 2) * dpr))
              });
            }
            ctx.globalCompositeOperation = 'lighter';
            ctx.strokeStyle = '#ffffff';
            for (let i = streaks.length - 1; i >= 0; i--) {
              const s = streaks[i];
              s.y += s.vy * dt;
              ctx.globalAlpha = Math.max(0, Math.min(1, s.a));
              ctx.lineWidth = s.w;
              ctx.beginPath();
              ctx.moveTo(s.x, s.y);
              ctx.lineTo(s.x, s.y - s.len);
              ctx.stroke();
              if (s.y < -s.len) streaks.splice(i, 1);
            }
            ctx.globalAlpha = 1;
            this._speedFxRaf = requestAnimationFrame(step);
          };
          this._speedFxRaf = requestAnimationFrame((t)=>{ last=t; this._speedFxRaf=requestAnimationFrame(step); });
        }
      } catch(_) {}
    };
    this._stopSpeedStreaks = () => {
      try {
        if (this._speedFxRaf) cancelAnimationFrame(this._speedFxRaf);
        this._speedFxRaf = null;
        if (this._onResizeSpeedFx) { try { window.removeEventListener('resize', this._onResizeSpeedFx); } catch(_) {} this._onResizeSpeedFx = null; }
        if (this._speedFxCanvas) { try { this._speedFxCanvas.remove(); } catch(_) {} this._speedFxCanvas = null; }
      } catch(_) {}
    };

    // 餌の種類（画像・ランク）を切替
    this.setBaitType = (type) => {
      try { this._bait?.setType?.(type); } catch(_) {}
    };

    this._startScrollBg = () => {
      if (!this._scrollBg) return;
      const speedSecPerTile = 8; // 1タイルを8秒で流す（以前と同等）
      let last = performance.now();
      let offset = 0; // px
      const loop = (t) => {
        const dt = (t - last) / 1000; last = t;
        const tileH = this._tileH || this._scrollBg.clientHeight || 1024;
        const base = tileH / speedSecPerTile; // px/s
        const speed = base * (this._scrollSpeedMul || 1);
        offset = (offset + speed * dt) % tileH;
        this._scrollBg.style.backgroundPosition = `center ${-Math.floor(offset)}px`;
        // 深度更新（px→m換算）
        this._totalScrollPx = (this._totalScrollPx || 0) + speed * dt;
        this._clockSec = (this._clockSec || 0) + dt;
        this._updateDepthAndSpawns?.(dt);
        this._updateFishes?.(dt);
        this._scrollRaf = requestAnimationFrame(loop);
      };
      if (this._scrollRaf) cancelAnimationFrame(this._scrollRaf);
      this._scrollRaf = requestAnimationFrame((t)=>{ last=t; this._scrollRaf=requestAnimationFrame(loop); });
    };
    this._stopScrollBg = () => { if (this._scrollRaf) cancelAnimationFrame(this._scrollRaf); this._scrollRaf = null; };

    // 餌箱（右上 or ミニ）の魚画像を差し替え（任意src）
    this._setEsabakoSprite = (src, alt) => {
      try {
        // 旧: 右上版がなければミニを生成
        if (!this._esabakoMini) this._spawnEsabakoMini?.();
        const imgMini = this._esabakoMini?.querySelector?.('.ebi-img-mini');
        if (imgMini && src) {
          const pngSrc = src;
          const webpSrc = (src.endsWith('.png') ? src.replace(/\.png$/i, '.webp') : src);
          imgMini.onerror = () => { if (imgMini.src.endsWith('.webp')) { imgMini.onerror = null; imgMini.src = pngSrc; } };
          imgMini.src = webpSrc;
          imgMini.alt = alt || 'bait';
        }
        // ゲームHUD側のミニも同期
        const imgMiniGame = this._esabakoMiniGame?.querySelector?.('.ebi-img-mini');
        if (imgMiniGame && src) {
          const pngSrc = src;
          const webpSrc = (src.endsWith('.png') ? src.replace(/\.png$/i, '.webp') : src);
          imgMiniGame.onerror = () => { if (imgMiniGame.src.endsWith('.webp')) { imgMiniGame.onerror = null; imgMiniGame.src = pngSrc; } };
          imgMiniGame.src = webpSrc;
          imgMiniGame.alt = alt || 'bait';
        }
        // 右上版もあれば同期
        const img = this._esabakoGroup?.querySelector?.('.ebi-img');
        if (img && src) {
          const pngSrc = src;
          const webpSrc = (src.endsWith('.png') ? src.replace(/\.png$/i, '.webp') : src);
          img.onerror = () => { if (img.src.endsWith('.webp')) { img.onerror = null; img.src = pngSrc; } };
          img.src = webpSrc;
          img.alt = alt || 'bait';
        }
      } catch(_) {}
    };
    // 餌箱（ミニ優先）の魚画像を差し替え（id基準）
    // fishes/ と fish/ の両方を試し、既知の別名も考慮。最終的に共通シルエットへフォールバック。
    this._setEsabakoById = (id) => {
      try {
        if (!id) return;
        const altMap = {
          maaji: 'aji',
          maiwashi: 'iwashi',
          masaba: 'saba',
          madai: 'tai',
          shiirakansu: 'si-rakansu',
          atorantikkusaamon: 'atoranteikkusaamon'
        };
        const alts = [id];
        if (altMap[id]) alts.push(altMap[id]);
        // 候補（pngベースを列挙）: fishes/ → fish/ → 別名（同順）
        const bases = [];
        for (const name of alts) {
          bases.push(`assets/fishes/${name}.png`);
          bases.push(`assets/fish/${name}.png`);
        }
        bases.push('assets/fish.png'); // 最終退避

        // 画像要素ターゲット（存在するもの全てを同期更新）
        const targets = [];
        try { if (!this._esabakoMini) this._spawnEsabakoMini?.(); } catch(_) {}
        const t1 = this._esabakoMini?.querySelector?.('.ebi-img-mini');
        const t2 = this._esabakoMiniGame?.querySelector?.('.ebi-img-mini');
        const t3 = this._esabakoGroup?.querySelector?.('.ebi-img');
        if (t1) targets.push(t1);
        if (t2) targets.push(t2);
        if (t3) targets.push(t3);
        if (!targets.length) return;

        // 個々の <img> に対して順次フォールバック（webp→png→次候補）
        const applyWithFallback = (imgEl) => {
          let idx = 0;
          let phase = 'webp';
          const trySet = () => {
            const base = bases[Math.min(idx, bases.length - 1)];
            if (!base) return;
            // webp を先に試し、失敗したら png、さらに次候補
            const webp = base.replace(/\.png$/i, '.webp');
            const png = base;
            imgEl.onerror = () => {
              if (phase === 'webp') {
                phase = 'png';
                imgEl.onerror = () => {
                  // 次の候補へ
                  idx += 1; phase = 'webp';
                  if (idx < bases.length) { trySet(); }
                };
                imgEl.src = png;
              } else {
                // png も失敗 → 次候補
                idx += 1; phase = 'webp';
                if (idx < bases.length) { trySet(); }
              }
            };
            // 初手は webp
            imgEl.src = webp;
            try { imgEl.alt = id || 'bait'; } catch(_) {}
          };
          trySet();
        };

        for (const img of targets) applyWithFallback(img);
      } catch(_) {}
    };

    // GET演出: 動画画面へ遷移し、GETテキストと魚名画像を表示、餌を差し替え
    this._onGetFish = async (def) => {
      if (this._handlingGet && !this._skipPreTautFlow) return;
      this._handlingGet = true;
      try {
        // 演出のリセットは不要（沈み演出を廃止）
        // まず糸を張って浮きを上昇（当たり停止）
        this._gameActive = false;
        this._stopScrollBg?.();
        if (!this._skipPreTautFlow) {
          await this._playTautAndFloatAnim?.();
          await this._liftBaitShort?.();
        }
        // 以降はロープ無効化
        this._ropeEnabled = false; if (this._ropeCanvas) this._ropeCanvas.style.display = 'none';
        // 黒フェードで一旦ブロック
        await this._showBlack();
        // 動画画面へ切り戻し（turigamennsyoki.mp4 を再生して表示）
        if (this._videoEl) {
          this._videoEl.style.display = 'block';
          try {
            if (!/turigamennsyoki\.mp4$/i.test(this._videoEl.currentSrc||this._videoEl.src||'')) {
              this._videoEl.src = 'assets/turigamennsyoki.mp4';
              this._videoEl.load();
            }
            try { this._videoEl.play?.(); } catch(_) {}
          } catch(_) {}
        }
        // 餌は動画復帰中は非表示
        try { this._bait?.hide?.(); } catch(_) {}
        // ロープは動画中は描画しない
        try { this._ropeEnabled = false; if (this._ropeCanvas) this._ropeCanvas.style.display = 'none'; } catch(_) {}
        // 既存の魚をすべて消す（念のためDOM掃除も）
        try { this._safe?.querySelectorAll?.('.fish-sprite')?.forEach(el => el.remove()); } catch(_) {}
        if (this._scrollBg) this._scrollBg.style.display = 'none';
        if (this._gameBlackBg) this._gameBlackBg.style.display = 'none';
        if (this._blackBelow) this._blackBelow.style.display = 'block';
        // 既存の魚を配列側でもすべて消す
        try {
          for (const ff of this._fishes || []) { try { ff.unmount(); } catch(_) {} }
        } catch(_) {}
        this._fishes = [];
        this._spawners = [];
        // 餌・餌箱の更新はワイプ終了後に行う（ここでは保留）
        this._pendingBaitId = def?.id;
        this._pendingBaitRank = def?.rank || 0;
        // 自動セーブ（釣果とエサを更新）
        try { SaveManager.updateAfterGet(this.state, def); } catch(_) {}
        // 動画を確実に可視化→黒を外して見せる
        await this._ensureVideoVisible();
        await this._waitForVideoReady(1200);
        // まず動画を上から元位置へスライドダウンするため、開始オフセットを与える
        try { this._applyVideoAnim?.(-100); } catch(_) {}
        await this._hideBlack();
        await this._playVideoSlideFromTop(800, -100);
        // 動画画面に復帰したので「タイトルへ」を表示
        this._setBackVisible?.(true);
        // 既存の魚オーバーレイ/裏キャンバスが残っていれば掃除
        try { this._layer?.querySelectorAll?.('.caught-fish-overlay,.get-backdrop-canvas')?.forEach(el=>el.remove()); } catch(_) {}
        // 釣れた魚スプライトを先に表示
        this._showCaughtFish?.(def);
        // 裏面生成は一時停止（重複に見えるため）
        // GETバッジのみ前面に重ねる
        try { this._showGetBadgePattern?.(); } catch(_) {}
        // 餌・餌箱の見た目更新はワイプ完了後に実施（ここでは何もしない）
        // 少し見せたら自動でワイプ→自動復帰
        setTimeout(()=>{ this._runWipeAndReturn?.(); }, 1200);
        // 自動復帰にするので、タップ待ちフラグは使用しない
        this._seqStarted = false;
        this._awaitingRestart = false;
      } finally {
        this._handlingGet = false;
        this._skipPreTautFlow = false;
      }
    };

    // GETオーバーレイの生成と一時表示
    this._showGetOverlay = (def) => {
      if (!this._layer) return;
      const ov = document.createElement('div');
      ov.className = 'get-overlay';
      const getText = document.createElement('div');
      getText.className = 'get-text';
      getText.textContent = 'GET';
      const nameWrap = document.createElement('div');
      nameWrap.className = 'get-namewrap';
      const nameImg = document.createElement('img');
      nameImg.className = 'name-img';
      const base = 'assets/fishes';
      const jaPath = def?.name_ja ? `${base}/${def.name_ja}.png` : '';
      const idPath = `${base}/${def?.id||'unknown'}.png`;
      // 日本語名優先、無ければidにフォールバック
      nameImg.src = jaPath || idPath;
      nameImg.alt = def?.name_ja || def?.id || 'fish';
      nameImg.onerror = () => { if (nameImg.src !== idPath) nameImg.src = idPath; else nameImg.style.display = 'none'; };
      const nameText = document.createElement('div');
      nameText.className = 'name-text';
      nameText.textContent = def?.name_ja || def?.id || '';
      nameWrap.appendChild(nameImg);
      nameWrap.appendChild(nameText);
      ov.appendChild(getText);
      ov.appendChild(nameWrap);
      this._layer.appendChild(ov);
      // 一定時間後にフェードアウトして削除→ワイプ→自動復帰
      setTimeout(()=>{ ov.classList.add('fadeout'); }, 1100);
      setTimeout(()=>{ try { ov.remove(); } catch(_) {} this._runWipeAndReturn?.(); }, 1700);
    };

    // 釣れた魚スプライトを中央表示
    this._showCaughtFish = (def) => {
      if (!this._layer) return;
      const ov = document.createElement('div');
      ov.className = 'caught-fish-overlay';
      const img = document.createElement('img');
      img.className = 'caught-fish-img';
      // 画像は assets/fishes/{id}.png を優先採用
      const src = def?.id ? `assets/fishes/${def.id}.png` : '';
      if (src) img.src = src; else try { img.src = 'assets/fish.png'; } catch(_) {}
      img.alt = def?.name_ja || def?.id || 'fish';
      // 読み込み失敗時はシルエットで代替し、最終的に何も出ない状態を回避
      img.onerror = () => {
        if (img.src.includes('assets/fish.png')) { return; }
        try { img.src = 'assets/fish.png'; } catch(_) {}
      };
      // テキストラベル（念のため画像が出なくても名前を見せる）
      const label = document.createElement('div');
      label.className = 'caught-fish-label';
      label.textContent = def?.name_ja || def?.id || '';
      ov.appendChild(img);
      ov.appendChild(label);
      this._layer.appendChild(ov);
    };

    // GETバッジのみ前面に表示（パターンなし）
    this._showGetBadgePattern = () => {
      if (!this._layer) return;
      try { this._layer.querySelectorAll('.get-badge-overlay')?.forEach(el=>el.remove()); } catch(_) {}
      const wrap = document.createElement('div');
      wrap.className = 'get-badge-overlay';
      const badge = document.createElement('img');
      badge.className = 'get-badge-img';
      badge.src = 'assets/GET.png';
      badge.alt = 'GET';
      badge.onerror = () => { try { badge.style.display = 'none'; } catch(_) {} };
      wrap.appendChild(badge);
      this._layer.appendChild(wrap);
    };

    // 魚PNGの“裏”に同サイズで徐々に描画（左上から埋める）
    this._showFishBackdropReveal = (def, opts = {}) => {
      if (!this._layer || !this._safe || !def) return;
      const ov = this._layer.querySelector?.('.caught-fish-overlay');
      const frontImg = ov?.querySelector?.('.caught-fish-img');
      if (!ov || !frontImg) return;
      // 既存キャンバス除去
      try { ov.querySelectorAll('.get-backdrop-canvas')?.forEach(el=>el.remove()); } catch(_) {}
      // 魚オーバーレイの先頭に挿入（背面）
      const cvs = document.createElement('canvas');
      cvs.className = 'get-backdrop-canvas';
      try { ov.insertBefore(cvs, ov.firstChild); } catch(_) { ov.appendChild(cvs); }

      const durationMs = Math.max(200, opts.durationMs || 1000);
      const fit = () => {
        const r = this._safe.getBoundingClientRect();
        const dpr = Math.max(1, window.devicePixelRatio||1);
        cvs.width = Math.max(1, Math.floor(r.width * dpr));
        cvs.height = Math.max(1, Math.floor(r.height * dpr));
        cvs.style.width = r.width + 'px';
        cvs.style.height = r.height + 'px';
        return { r, dpr };
      };
      let { r, dpr } = fit();
      const ctx = cvs.getContext('2d', { alpha: true }); if (!ctx) return;
      ctx.imageSmoothingEnabled = true;

      const waitBounds = () => new Promise((resolve) => {
        const poll = () => {
          if (!cvs.isConnected) { resolve(null); return; }
          const ir = frontImg?.getBoundingClientRect();
          if (ir && ir.width > 2 && ir.height > 2) { resolve(ir); return; }
          requestAnimationFrame(poll);
        };
        poll();
      });

      const img = new Image();
      const frontSrc = (frontImg?.currentSrc || frontImg?.src || '');
      const fallbackSrc = def?.id ? `assets/fishes/${def.id}.png` : 'assets/fish.png';
      img.src = frontSrc || fallbackSrc;
      img.onerror = () => { try { img.src = 'assets/fish.png'; } catch(_) {} };

      (async () => {
        const ir = await waitBounds(); if (!ir) return;
        await new Promise((res) => { if (img.complete && img.naturalWidth) res(); else img.onload = () => res(); });
        const sr = this._safe.getBoundingClientRect();
        let dx = Math.floor((ir.left - sr.left) * dpr);
        let dy = Math.floor((ir.top - sr.top) * dpr);
        let dw = Math.floor(ir.width * dpr);
        let dh = Math.floor(ir.height * dpr);

        const tilesX = Math.max(6, Math.round(ir.width / 26));
        const tilesY = Math.max(6, Math.round(ir.height / 26));
        const sw = img.naturalWidth, sh = img.naturalHeight;
        const twSrc = sw / tilesX, thSrc = sh / tilesY;
        const twDst = dw / tilesX, thDst = dh / tilesY;

        let last = 0;
        const total = tilesX * tilesY;
        const start = performance.now();

        const loop = (t) => {
          if (!cvs.isConnected) return;
          // リサイズ追随
          const rNow = this._safe.getBoundingClientRect();
          if (Math.abs(rNow.width - r.width) > 1 || Math.abs(rNow.height - r.height) > 1) {
            ({ r, dpr } = fit());
            dx = Math.floor((ir.left - rNow.left) * dpr);
            dy = Math.floor((ir.top - rNow.top) * dpr);
            dw = Math.floor(ir.width * dpr);
            dh = Math.floor(ir.height * dpr);
          }
          const p = Math.min(1, (t - start) / Math.max(1, durationMs));
          const n = Math.floor(total * p);
          for (let i = last; i < n; i++) {
            const ry = Math.floor(i / tilesX);
            const rx = i % tilesX;
            const sx = Math.floor(rx * twSrc);
            const sy = Math.floor(ry * thSrc);
            const dxp = Math.floor(dx + rx * twDst);
            const dyp = Math.floor(dy + ry * thDst);
            ctx.drawImage(img, sx, sy, Math.ceil(twSrc), Math.ceil(thSrc), dxp, dyp, Math.ceil(twDst), Math.ceil(thDst));
          }
          last = n;
          if (p < 1) requestAnimationFrame(loop);
        };
        requestAnimationFrame(loop);
      })();
    };

    // 黒い画面が左→右に高速で走るワイプ演出
    this._runWipeAndReturn = () => {
      if (!this._layer) return;
      const w = document.createElement('div');
      w.className = 'wipe-overlay';
      const strip = document.createElement('div');
      strip.className = 'wipe-strip';
      w.appendChild(strip);
      this._layer.appendChild(w);
      // ワイプ進行中にGET系要素を左から順にクリップして“拭き取り”
      let wipeClipRaf = null;
      const clipTargetsSel = '.get-overlay,.caught-fish-overlay,.get-badge-overlay,.get-backdrop-overlay,.get-backdrop-canvas,.get-pattern-canvas,.get-badge-img';
      const stepClip = () => {
        try {
          const lr = this._layer?.getBoundingClientRect?.();
          const sr = strip.getBoundingClientRect();
          if (lr && sr) {
            // グローバル境界（レイヤー左原点からの絶対px）
            const boundaryX = (sr.left - lr.left) + sr.width;
            const els = this._layer?.querySelectorAll?.(clipTargetsSel) || [];
            els.forEach(el => {
              try {
                const er = el.getBoundingClientRect();
                // 要素ローカル座標系での左クリップ量 = 境界X - 要素の左端（どちらもレイヤー基準）
                let leftCrop = boundaryX - Math.max(0, (er.left - lr.left));
                // 0..要素幅にクランプ
                leftCrop = Math.max(0, Math.min(Math.floor(leftCrop), Math.floor(er.width)));
                el.style.clipPath = `inset(0 0 0 ${leftCrop}px)`;
              } catch(_) {}
            });
          }
        } catch(_) {}
        wipeClipRaf = requestAnimationFrame(stepClip);
      };
      wipeClipRaf = requestAnimationFrame(stepClip);
      // 終了後に除去
      const onEnd = () => {
        strip.removeEventListener('animationend', onEnd);
        try { if (wipeClipRaf) cancelAnimationFrame(wipeClipRaf); } catch(_) {}
        try { w.remove(); } catch(_) {};
        // 残っているGET/魚/GETバッジ/バックドロップのオーバーレイ/キャンバスがあれば消す
        try {
          this._layer?.querySelectorAll?.(
            '.get-overlay,.caught-fish-overlay,.get-badge-overlay,.get-backdrop-overlay,.get-backdrop-canvas,.get-pattern-canvas,.get-badge-img'
          )?.forEach(el=>el.remove());
        } catch(_) {}
        // タップ待ちの初期状態へ（動画画面のまま）
        this._awaitingRestart = true;
        this._seqStarted = false;
        // 動画画面なので「タイトルへ」を再表示
        this._setBackVisible?.(true);
        // 動画画面では現在水深を0mにリセットして表示
        try { this._totalScrollPx = 0; this._depthMeters = 0; this._renderDepth?.(); } catch(_) {}
        // 保留していた餌・餌箱の更新をここで反映（次ターン用）
        try {
          if (this._pendingBaitId) {
            const id = this._pendingBaitId; const rank = this._pendingBaitRank || 0;
            this._bait?.setLogicalRank?.(rank, id);
            this._setEsabakoById?.(id);
            this._pendingBaitId = null; this._pendingBaitRank = null;
          }
        } catch(_) {}
        // ゲームHUDを隠し、トップセットを再表示（再度ひょっこり）
        try {
          const hud = this.root.querySelector('#gameHud'); if (hud) hud.style.display = 'none';
          const group = this.root.querySelector('#topsetGroup');
          if (group) {
            group.style.display = '';
            const items = group.querySelectorAll('.topset-item');
            items.forEach(el => { el.classList.remove('exit'); void el.offsetWidth; el.classList.add('enter'); });
          }
          this._fitTopset?.();
          // TAPガイドを再表示（動画での再スタート待機）
          this._showTapGuide?.();
        } catch(_) {}
      };
      strip.addEventListener('animationend', onEnd);
      // 既に動画画面は表示中（このワイプは視覚効果のみ）。動画は再生しない。
      // 自動復帰に切り替えたため、フラグ操作は onEnd 側で行う
    };

    // --- Fish System ------------------------------------------------------
    // パラメータ
    this._pxPerMeter = 20; // 標準を1/5の速度に: 20px=1m（従来4px=1mの5倍）
    this._rankStepMeters = 50; // 50mごとに新しいランク解放
    this._rankWindowMeters = 200; // 解放ランクは+200mの深さまでスポーン
    this._fishes = [];
    this._spawners = []; // {rank,startDepth,endDepth,nextAtSec}
    this._lastUnlockedIndex = -1; // -1→まだ未解放、0→rank1解放 等

    this._initFishSystem = () => {
      // 最初の解放（rank1を0mから）
      this._depthMeters = 0;
      this._maxDepthMeters = 0;
      this._clockSec = 0;
      this._totalScrollPx = 0;
      this._spawners = [];
      this._fishes = [];
      this._lastUnlockedIndex = -1;
      this._tryUnlockRanks?.();
      this._renderDepth?.();
    };

    this._tryUnlockRanks = () => {
      const depth = Math.floor(this._depthMeters || 0);
      const unlockIdx = Math.floor(depth / this._rankStepMeters);
      while (this._lastUnlockedIndex < unlockIdx) {
        const nextIdx = this._lastUnlockedIndex + 1; // 0-based
        const rank = 1 + nextIdx; // rank1から開始
        // fish.json 未ロードや最大ランク超過は無視
        const maxRank = Array.isArray(this._fishData) ? this._fishData.reduce((m,f)=>Math.max(m, f.rank||0), 0) : 0;
        if (rank <= 0 || (maxRank && rank > maxRank)) { this._lastUnlockedIndex = nextIdx; continue; }
        const startDepth = nextIdx * this._rankStepMeters;
        const endDepth = startDepth + this._rankWindowMeters;
        this._spawners.push({ rank, startDepth, endDepth, nextAtSec: (this._clockSec||0) + Math.random()*1.2 + 0.6 });
        this._lastUnlockedIndex = nextIdx;
      }
    };

    this._pickFishDefByRank = (rank) => {
      const list = (this._fishData||[]).filter(f => f.rank === rank);
      if (!list.length) return null;
      return list[Math.floor(Math.random()*list.length)];
    };

    this._spawnFishFromBottom = (def) => {
      if (!def || !this._safe) return;
      const dir = Math.random() < 0.5 ? 'left' : 'right';
      // 全魚: 下からスポーンし、ベースは rise
      const fish = new Fish({ parent: this._safe, def: { ...def, movement: { ...(def.movement||{}), pattern: 'rise' } }, direction: dir, overrideSprite: 'assets/fish.png' });
      try { fish.mount(); } catch(_) { return; }
      const r = this._safe.getBoundingClientRect();
      const x = Math.floor(r.width * (0.1 + Math.random()*0.8));
      const y = r.height + 30; // 画面下の少し外
      fish.setPosition(x, y);
      fish.applyMovementPreset();
      // ラッシュ系の追加挙動が指定されている場合、目標(X,Y)を餌の現在位置に初期化
      try {
        const mv = fish.def?.movement || {};
        if (mv.rushToBaitX) {
          const baitRect = (this._bait?.getHitRect?.() || this._bait?.getBounds?.());
          if (baitRect && this._safe) {
            const sr = this._safe.getBoundingClientRect();
            const lc = this._rectToLocal?.(baitRect, sr) || { x: baitRect.left - sr.left, y: baitRect.top - sr.top, width: baitRect.width, height: baitRect.height };
            const bx = lc.x + lc.width / 2;
            const by = lc.y + lc.height / 2;
            fish._rushTargetX = bx;
            fish._rushTargetY = by;
            // 非ホーミングの場合はスポーン時点で方向を固定
            if (!mv.rushHoming) {
              const dx = bx - fish.x; const dy = by - fish.y;
              const len = Math.hypot(dx, dy) || 1e-4;
              fish._rushUx = dx / len; fish._rushUy = dy / len;
            }
          }
        }
      } catch(_) {}
      this._fishes.push(fish);
    };
    // 横方向からスポーン（画面外から水平移動で入場）
    this._spawnFishFromSide = (def, dir = (Math.random() < 0.5 ? 'right' : 'left'), yPos = null) => {
      if (!def || !this._safe) return;
      const fish = new Fish({ parent: this._safe, def: { ...def }, direction: dir, overrideSprite: 'assets/fish.png' });
      try { fish.mount(); } catch(_) { return; }
      const r = this._safe.getBoundingClientRect();
      const y = (yPos != null) ? yPos : Math.floor(r.height * (0.25 + Math.random()*0.5));
      const x = (dir === 'right') ? -30 : (r.width + 30);
      fish.setPosition(x, y);
      fish.applyMovementPreset();
      this._fishes.push(fish);
    };
    // 魚群スポーン（横断）: 同一種をまとまった帯で左右いずれかから入場
    this._spawnSchoolFromSide = (def, count = 10) => {
      if (!def || !this._safe) return;
      const dir = (Math.random() < 0.5) ? 'right' : 'left';
      const r = this._safe.getBoundingClientRect();
      const yBase = Math.floor(r.height * (0.3 + Math.random() * 0.4));
      for (let i = 0; i < Math.max(1, count); i++) {
        const jitterY = Math.round((Math.random() - 0.5) * 70);
        const fDef = { ...def, movement: { ...(def.movement||{}), allowOffscreenX: true, despawnOffX: Math.max(120, (def.movement?.despawnOffX||120)) } };
        this._spawnFishFromSide(fDef, dir, yBase + jitterY);
      }
    };
    // 縦隊スポーン（上昇）: 同一xで等間隔に複数体を下から出現
    this._spawnColumnRise = (def, count = 3, spacing = 28) => {
      if (!def || !this._safe) return;
      const r = this._safe.getBoundingClientRect();
      const x = Math.floor(r.width * (0.2 + Math.random()*0.6));
      for (let i = 0; i < Math.max(1, count); i++) {
        const fish = new Fish({ parent: this._safe, def: { ...def, movement: { ...(def.movement||{}), pattern: 'rise' } }, direction: (Math.random()<0.5?'left':'right'), overrideSprite: 'assets/fish.png' });
        try { fish.mount(); } catch(_) { continue; }
        const y = r.height + 30 + i * spacing;
        fish.setPosition(x, y);
        fish.applyMovementPreset();
        this._fishes.push(fish);
      }
    };

    this._updateDepthAndSpawns = (dt) => {
      // 深度更新
      const px = this._totalScrollPx || 0;
      const ppm = this._pxPerMeter || 4;
      this._depthMeters = px / ppm;
      // 最大到達深度の更新と表示
      if ((this._maxDepthMeters || 0) < (this._depthMeters || 0)) {
        this._maxDepthMeters = this._depthMeters;
      }
      this._renderDepth?.();
      // 解放チェック
      this._tryUnlockRanks?.();
      // スポーン（アクティブウィンドウのみ）
      const now = this._clockSec || 0;
      for (const sp of this._spawners) {
        if (this._depthMeters < sp.startDepth || this._depthMeters > sp.endDepth) continue;
        if (now >= sp.nextAtSec) {
          const baseDef = this._pickFishDefByRank(sp.rank) || { id: `rank${sp.rank}`, name_ja:`R${sp.rank}`, rank: sp.rank, movement:{ pattern:'rise', speed: 60, amplitude:0, frequency:0, sizeScale: 1 } };
          // 魚ごとのスポーン確率（spawnChance 0..1）が指定されていれば抽選
          const chance = (baseDef && typeof baseDef.spawnChance === 'number') ? Math.max(0, Math.min(1, baseDef.spawnChance)) : 1;
          if (Math.random() <= chance) {
            // 特殊スポーンルート（IDで分岐）
            if (baseDef.id === 'maiwashi') {
              const def = { ...baseDef, movement: { ...(baseDef.movement||{}), pattern: 'straight', allowOffscreenX: true, despawnOffX: Math.max(120, baseDef.movement?.despawnOffX||120) } };
              this._spawnSchoolFromSide(def, 10 + Math.floor(Math.random()*6));
            } else if (baseDef.id === 'sake') {
              const def = { ...baseDef, movement: { ...(baseDef.movement||{}), pattern: 'sine', allowOffscreenX: true, despawnOffX: Math.max(120, baseDef.movement?.despawnOffX||120) } };
              this._spawnFishFromSide(def, (Math.random()<0.5?'right':'left'));
            } else if (baseDef.id === 'masaba') {
              this._spawnColumnRise(baseDef, 3, 32);
            } else {
              this._spawnFishFromBottom(baseDef);
            }
          }
          // 次回スポーン（ランダム間隔 0.8〜1.6s）
          sp.nextAtSec = now + (0.8 + Math.random()*0.8);
        }
      }
    };

    this._updateFishes = (dt) => {
      if (!this._gameActive) return;
      if (this._handlingGet) return; // GET進行中は当たりを止める
      // 位置更新＆当たり判定＆GC
      const baitRect = (this._bait?.getHitRect?.() || this._bait?.getBounds?.()) || null;
      for (let i = this._fishes.length - 1; i >= 0; i--) {
        const f = this._fishes[i];
        // 餌の現在位置（セーフ座標）を計算
        let baitCX = null, baitCY = null;
        try {
          if (baitRect && this._safe) {
            const sr = this._safe.getBoundingClientRect();
            const lc = this._rectToLocal?.(baitRect, sr) || { x: baitRect.left - sr.left, y: baitRect.top - sr.top, width: baitRect.width, height: baitRect.height };
            baitCX = lc.x + lc.width / 2;
            baitCY = lc.y + lc.height / 2;
          }
        } catch(_) {}
        // 逃避ターゲット（餌X）を逐次更新（avoid挙動用）
        try {
          if (f && f._avoidFromBaitX && baitCX != null) {
            f._avoidTargetX = baitCX;
          }
        } catch(_) {}
        // 突進ターゲット（餌X,Y）も逐次更新（rush挙動用）
        try {
          if (f && f._rushToBaitX && baitCX != null && baitCY != null) {
            f._rushTargetX = baitCX;
            f._rushTargetY = baitCY;
          }
        } catch(_) {}
        // サンプリング追尾（一定間隔で方向をサンプル）
        try {
          if (f && f._sampleSeekEnabled && baitCX != null && baitCY != null) {
            f._seekTargetX = baitCX;
            f._seekTargetY = baitCY;
          }
        } catch(_) {}
        // レンジ内チェイス（餌）
        try {
          if (f && f._chaseInRange && baitCX != null && baitCY != null) {
            f._chaseTargetX = baitCX;
            f._chaseTargetY = baitCY;
          }
        } catch(_) {}
        // 第二近接魚への追尾ターゲットを更新
        try {
          if (f && f._seekSecondNearestFish) {
            let nearest1 = null, nearest2 = null;
            for (let j = 0; j < this._fishes.length; j++) {
              const g = this._fishes[j];
              if (!g || g === f || !g.el || g.isFleeing?.()) continue;
              const dx = (g.x - f.x), dy = (g.y - f.y);
              const d2 = dx*dx + dy*dy;
              if (!nearest1 || d2 < nearest1.d2) { nearest2 = nearest1; nearest1 = { g, d2 }; }
              else if (!nearest2 || d2 < nearest2.d2) { nearest2 = { g, d2 }; }
            }
            const target = nearest2?.g || nearest1?.g || null;
            if (target) { f._seekOtherTargetX = target.x; f._seekOtherTargetY = target.y; }
          }
        } catch(_) {}
        // 世界速度倍率を魚へ伝播
        try { f.worldSpeedMul = this._scrollSpeedMul || 1; } catch(_) {}
        try { f.update(dt); } catch(_) {}
        // 画面外（上）で破棄
        if (!f.el || f.y < -40) {
          try { f.unmount(); } catch(_) {}
          this._fishes.splice(i,1);
          continue;
        }
        // 魚同士の衝突で反射（ランダム直進＋reflectOnFishHit）
        try {
          // クールダウン更新
          f._reflectCooldown = Math.max(0, (f._reflectCooldown || 0) - dt);
          if (f._reflectOnFishHit && f._randStraightEnabled && f._randStraightSpeed > 0 && f._reflectCooldown <= 0) {
            const fr = f.el?.getBoundingClientRect?.();
            if (fr) {
              const r1 = Math.max(2, fr.width * 0.45);
              for (let j = 0; j < this._fishes.length; j++) {
                if (j === i) continue;
                const g = this._fishes[j];
                if (!g || !g.el || g.isFleeing?.()) continue;
                const gr = g.el.getBoundingClientRect?.();
                if (!gr) continue;
                const dx = (f.x - g.x);
                const dy = (f.y - g.y);
                const dist = Math.hypot(dx, dy);
                const r2 = Math.max(2, gr.width * 0.45);
                if (isFinite(dist) && dist > 0 && dist < (r1 + r2)) {
                  // 反射: d' = d - 2*(d·n)*n （n は g→f 方向）
                  const nx = dx / dist, ny = dy / dist;
                  let ux = f._randUx || 0, uy = f._randUy || 0;
                  const dot = ux * nx + uy * ny;
                  ux = ux - 2 * dot * nx; uy = uy - 2 * dot * ny;
                  const ln = Math.hypot(ux, uy) || 1;
                  f._randUx = ux / ln; f._randUy = uy / ln;
                  f.direction = (f._randUx >= 0) ? 'right' : 'left';
                  // 押し戻しとクールダウン
                  f.x += nx * 3; f.y += ny * 3;
                  f._reflectCooldown = 0.2;
                  break;
                }
              }
            }
          }
        } catch(_) {}
        // 横方向の許容オフスクリーン範囲を超えたら破棄（allowOffscreenX）
        try {
          if (f._allowOffscreenX && this._safe) {
            const sr = this._safe.getBoundingClientRect();
            const off = Math.max(0, f._despawnOffX || 100);
            if (f.x < -off || f.x > (sr.width + off)) {
              try { f.unmount(); } catch(_) {}
              this._fishes.splice(i,1);
              continue;
            }
          }
        } catch(_) {}
        // 当たり判定
        // 1) 糸（ロープ）との衝突: 触れた瞬間に当たりを無効化しつつフェードアウト演出
        try {
          if (this._ropeEnabled && this._ropePts && this._safe && !f.isFleeing?.()) {
            const safeRect = this._safe.getBoundingClientRect();
            const frAbs = (f.getHitRect?.() || f.getBounds?.());
            if (frAbs) {
              const frLocal = this._rectToLocal(frAbs, safeRect);
              if (this._ropeHitsRect?.(frLocal, 8)) {
                f.startFleeAndFadeOut?.(520, 1.1);
                // このフレームは以降の処理をスキップ（次フレーム以降に自然消滅）
                continue;
              }
            }
          }
        } catch(_) {}
        // 2) 餌（bait）との衝突
        const fishRect = f.getHitRect?.();
        if (baitRect && fishRect && this._intersects?.(baitRect, fishRect)) {
          const baitRank = this._bait?.getRank?.() || 0;
          const fishRank = f.def?.rank || 0;
          if (baitRank <= fishRank) {
            // 釣り上げ（GET）: まず糸を先にぴんと張る→そのまま引き上げ→その後のGETフロー
            if (this._handlingGet) { /* 二重発火防止 */ } else { this._handlingGet = true; }
            // アンカーXは中央（見せ方として“起点”へ向かう）
            let yTopOff = -220; let anchorY = -360;
            try {
              const r = this._safe?.getBoundingClientRect();
              if (r) {
                this._setRopeAnchorX?.(Math.floor(r.width/2));
                // 画面外まで確実に持ち上げる（セーフ高さの90%分上へ）
                yTopOff = -Math.max(240, Math.floor(r.height * 0.9));
                // アンカーは十分上へ（セーフ高さの60%分上）
                anchorY = -Math.max(360, Math.floor(r.height * 0.6));
              }
            } catch(_) {}
            // ロック＆ロープ強化
            this._lockBaitPos = true; this._skipPreTautFlow = true;
            try { this._ropeEnabled = true; if (this._ropeCanvas) this._ropeCanvas.style.display = 'block'; } catch(_) {}
            try { this._ropeIters = 24; this._ropeDamp = 0.9995; } catch(_) {}
            try { if (this._water) this._water.currentForce = 0; } catch(_) {}
            // 1) まず一瞬、下へ引っ張られる
            try {
              this._tugBaitDown?.(28, 110)
                .then(() => {
                  // 2) 次に糸を上へ素早く張る
                  return this._animRopeAnchorTo?.(anchorY, 140);
                })
                .then(() => {
                  // 3) 張ったまま、起点方向の直線で餌を画面外まで引き上げ
                  return this._pullBaitTowardAnchorLine?.(220, yTopOff);
                })
                .then(() => {
                  // 3.5) 念のため餌を非表示に（小画面でのチラ見え対策）
                  try { this._bait?.hide?.(); } catch(_) {}
                  // 4) GETフローへ（事前タイト済みなので _onGetFish 側はスキップ分岐）
                  this._onGetFish?.(f.def);
                });
            } catch(_) { this._onGetFish?.(f.def); }
          } else {
            // 加速（餌ランクが高い）: ランク差に応じて倍率・時間を動的決定
            const gap = Math.max(0, (baitRank || 0) - (fishRank || 0));
            // 倍率: 差 0→1.5, 差 4→2.5, 差 8→3.5, 上限12
            let mul = 1 + gap * 0.25;
            mul = Math.min(12, Math.max(1.5, mul));
            // 時間: 基本1.2s + 差x0.3s（上限12s）
            let dur = Math.min(12000, Math.floor(1200 + gap * 300));
            this.applySpeedBoost?.(mul, dur);
          }
          // ヒットした魚は消す
          try { f.unmount(); } catch(_) {}
          this._fishes.splice(i,1);
        }
      }
      // デバッグ描画
      this._drawHitDebug?.();
    };

    this._intersects = (a, b) => {
      if (!a || !b) return false;
      return !(a.right < b.left || a.left > b.right || a.bottom < b.top || a.top > b.bottom);
    };

    // --- Rope collision helpers ---
    this._pointInRect = (x, y, r) => (x >= r.x && x <= r.x + r.width && y >= r.y && y <= r.y + r.height);
    this._segmentsIntersect = (x1,y1,x2,y2, x3,y3,x4,y4) => {
      const eps = 1e-9;
      const cross = (ax,ay,bx,by,cx,cy) => (bx-ax)*(cy-ay) - (by-ay)*(cx-ax);
      const onSeg = (ax,ay,bx,by,cx,cy) => {
        return Math.min(ax,bx) - eps <= cx && cx <= Math.max(ax,bx) + eps && Math.min(ay,by) - eps <= cy && cy <= Math.max(ay,by) + eps && Math.abs(cross(ax,ay,bx,by,cx,cy)) <= eps;
      };
      const d1 = cross(x1,y1,x2,y2,x3,y3);
      const d2 = cross(x1,y1,x2,y2,x4,y4);
      const d3 = cross(x3,y3,x4,y4,x1,y1);
      const d4 = cross(x3,y3,x4,y4,x2,y2);
      if (((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) && ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0))) return true;
      if (Math.abs(d1) <= eps && onSeg(x1,y1,x2,y2,x3,y3)) return true;
      if (Math.abs(d2) <= eps && onSeg(x1,y1,x2,y2,x4,y4)) return true;
      if (Math.abs(d3) <= eps && onSeg(x3,y3,x4,y4,x1,y1)) return true;
      if (Math.abs(d4) <= eps && onSeg(x3,y3,x4,y4,x2,y2)) return true;
      return false;
    };
    this._lineIntersectsRect = (x1,y1,x2,y2, rect) => {
      if (this._pointInRect(x1,y1,rect) || this._pointInRect(x2,y2,rect)) return true;
      const rx = rect.x, ry = rect.y, rw = rect.width, rh = rect.height;
      // 4辺
      if (this._segmentsIntersect(x1,y1,x2,y2, rx,ry, rx+rw,ry)) return true; // 上
      if (this._segmentsIntersect(x1,y1,x2,y2, rx+rw,ry, rx+rw,ry+rh)) return true; // 右
      if (this._segmentsIntersect(x1,y1,x2,y2, rx,ry+rh, rx+rw,ry+rh)) return true; // 下
      if (this._segmentsIntersect(x1,y1,x2,y2, rx,ry, rx,ry+rh)) return true; // 左
      return false;
    };
    // 魚矩形（セーフ座標）にロープが触れているか（半径rで太らせ判定）
    this._ropeHitsRect = (rectLocal, radius = 8) => {
      try {
        if (!this._ropePts || !Array.isArray(this._ropePts) || this._ropePts.length < 2) return false;
        // 厚み分だけ矩形を拡張
        const er = { x: rectLocal.x - radius, y: rectLocal.y - radius, width: rectLocal.width + radius*2, height: rectLocal.height + radius*2 };
        const pts = this._ropePts;
        for (let i = 0; i < pts.length - 1; i++) {
          const p1 = pts[i], p2 = pts[i+1];
          if (this._lineIntersectsRect(p1.x, p1.y, p2.x, p2.y, er)) return true;
        }
      } catch(_) {}
      return false;
    };

    // --- Rope physics (Verlet) ---
    this._initRope = () => {
      if (!this._ropeCanvas || !this._safe) return;
      const r = this._safe.getBoundingClientRect();
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      this._ropeCanvas.width = Math.max(1, Math.floor(r.width * dpr));
      this._ropeCanvas.height = Math.max(1, Math.floor(r.height * dpr));
      this._ropeCanvas.style.width = r.width + 'px';
      this._ropeCanvas.style.height = r.height + 'px';
      // rope points
      const N = 28; // セグメント数
      const segL = Math.max(8, r.height / (N + 2));
      this._ropeN = N;
      this._ropeSegL = segL;
      this._ropePts = new Array(N + 1).fill(0).map((_, i) => {
        const ax = (this._ropeAnchorX == null) ? (r.width / 2) : this._ropeAnchorX;
        const ay = (this._ropeAnchorY ?? -30); // 画面外の上（update側と一致）
        const y = ay + i * segL;
        return { x: ax, y, px: ax, py: y };
      });
      this._ropeLastT = performance.now();
      this._waterPhase = 0;
    };

    this._updateRope = (dt) => {
      if (!this._ropeEnabled) return;
      if (!this._ropePts || !this._safe) return;
      const r = this._safe.getBoundingClientRect();
      const N = this._ropeN || 0; if (!N) return;
      const pts = this._ropePts;
      const segL = this._ropeSegL || 16;
      const g = 900; // px/s^2 重力
      const damp = this._ropeDamp || 0.998; // 少し硬く（可変）
      const w = this._water || {};
      this._waterPhase = (this._waterPhase || 0) + ((w.currentPhaseSpeed ?? 0.7) * dt);
      const baseBuoy = Math.max(0, Math.min(0.98, (w.buoyancy ?? 0.9)));
      // 端点: アンカーと餌中心
      const ax = (this._ropeAnchorX == null) ? (r.width / 2) : this._ropeAnchorX;
      const ay = (this._ropeAnchorY ?? -30); // 画面外の上
      const baitRect = (this._bait?.getHitRect?.() || this._bait?.getBounds?.());
      let bx = pts[N].x, by = pts[N].y;
      if (baitRect) {
        const lc = this._rectToLocal(baitRect, r);
        bx = lc.x + lc.width / 2; by = lc.y + lc.height / 2;
      }
      // Verlet積分（内点のみ）
      for (let i = 1; i < N; i++) {
        const p = pts[i];
        const vx = (p.x - p.px) * damp;
        const vy = (p.y - p.py) * damp;
        p.px = p.x; p.py = p.y;
        p.x += vx;
        // 海流: 横方向にゆったり流す（下の節ほど強め）
        const sfrac = i / N;
        const flow = (w.currentForce ?? 160) * Math.sin(this._waterPhase + sfrac * 2 * Math.PI * (w.currentFreq ?? 0.18)) * sfrac;
        p.x += flow * dt * dt;
        // 節ごとの局所浮力（下の節ほど少し強く）
        const buoyLocal = Math.max(0, Math.min(0.98, baseBuoy + 0.06 * sfrac));
        const gEffLocal = g * (1 - buoyLocal);
        // 縦方向のうねり（上下動の加速度）。下の節ほど少し強めに影響
        const swell = (w.swellForce ?? 0) * Math.sin((this._waterPhase * (w.swellFreq ?? 0.4)) + sfrac * 2 * Math.PI);
        p.y += vy + gEffLocal * dt * dt - swell * dt * dt * (0.7 + 0.6 * sfrac);
      }
      // 拘束反復
      const iters = this._ropeIters || 10; // 少し硬く（可変）
      for (let k = 0; k < iters; k++) {
        // 再度端点を固定
        pts[0].x = ax; pts[0].y = ay;
        pts[N].x = bx; pts[N].y = by;
        for (let i = 0; i < N; i++) {
          const p1 = pts[i]; const p2 = pts[i + 1];
          let dx = p2.x - p1.x; let dy = p2.y - p1.y;
          let dist = Math.hypot(dx, dy) || 1e-6;
          const diff = (dist - segL) / dist;
          // 端の固定処理
          if (i === 0) {
            // p1固定→p2のみ補正
            p2.x -= dx * diff;
            p2.y -= dy * diff;
          } else if (i + 1 === N) {
            // p2固定→p1のみ補正
            p1.x += dx * diff;
            p1.y += dy * diff;
          } else {
            const half = 0.5;
            p1.x += dx * diff * half;
            p1.y += dy * diff * half;
            p2.x -= dx * diff * half;
            p2.y -= dy * diff * half;
          }
        }
      }
      // 最終固定
      pts[0].x = ax; pts[0].y = ay;
      pts[N].x = bx; pts[N].y = by;
    };

    // 深度追従ブースト（次のゲーム開始時に、目標深度へ数秒〜数十秒で到達させる）
    this._depthChase = { active: false, target: 0, margin: 20 };
    this._depthChaseMul = 1;
    this._pendingDepthChaseTarget = null;
    this._startDepthChase = (targetMeters) => {
      try {
        this._depthChase = { active: true, target: Math.max(0, Number(targetMeters||0)), margin: 20 };
        this._depthChaseMul = 1;
        this._startSpeedStreaks?.();
      } catch(_) {}
    };
    this._stopDepthChase = () => {
      try {
        this._depthChase.active = false;
        this._depthChaseMul = 1;
        this._stopSpeedStreaks?.();
      } catch(_) {}
    };

    // ロープ起点Xを即時変更
    this._setRopeAnchorX = (x) => { try { this._ropeAnchorX = Math.max(0, Math.floor(x||0)); } catch(_) {} };
    this._resetRopeAnchorXToCenter = () => {
      try {
        if (!this._safe) { this._ropeAnchorX = null; return; }
        const r = this._safe.getBoundingClientRect();
        this._ropeAnchorX = Math.floor(r.width / 2);
      } catch(_) { this._ropeAnchorX = null; }
    };

    this._drawRope = () => {
      if (!this._ropeEnabled) return;
      const cvs = this._ropeCanvas; if (!cvs || !this._ropePts || !this._safe) return;
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const r = this._safe.getBoundingClientRect();
      if (cvs.width !== Math.floor(r.width * dpr)) cvs.width = Math.max(1, Math.floor(r.width * dpr));
      if (cvs.height !== Math.floor(r.height * dpr)) cvs.height = Math.max(1, Math.floor(r.height * dpr));
      cvs.style.width = r.width + 'px';
      cvs.style.height = r.height + 'px';
      const ctx = cvs.getContext('2d'); if (!ctx) return;
      ctx.clearRect(0, 0, cvs.width, cvs.height);
      ctx.save();
      ctx.scale(dpr, dpr);
      // 描画
      const pts = this._ropePts; if (!pts || pts.length < 2) { ctx.restore(); return; }
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(230,235,240,0.95)';
      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
      ctx.stroke();
      ctx.restore();
    };

    this._drawHitDebug = () => {
      const cvs = this._hitboxCanvas; if (!cvs || !this._safe) return;
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const r = this._safe.getBoundingClientRect();
      if (cvs.width !== Math.floor(r.width * dpr)) cvs.width = Math.max(1, Math.floor(r.width * dpr));
      if (cvs.height !== Math.floor(r.height * dpr)) cvs.height = Math.max(1, Math.floor(r.height * dpr));
      cvs.style.width = r.width + 'px';
      cvs.style.height = r.height + 'px';
      const ctx = cvs.getContext('2d'); if (!ctx) return;
      ctx.clearRect(0, 0, cvs.width, cvs.height);
      ctx.save();
      ctx.scale(dpr, dpr);
      // Bait
      const bait = (this._bait?.getHitRect?.() || this._bait?.getBounds?.());
      if (bait) {
        const rr = this._rectToLocal(bait, r);
        ctx.strokeStyle = 'rgba(255,80,80,0.9)'; ctx.lineWidth = 2;
        ctx.strokeRect(rr.x, rr.y, rr.width, rr.height);
      }
      // Fishes
      for (const f of this._fishes) {
        const fr = (f.getHitRect?.() || f.getBounds?.());
        if (!fr) continue;
        const rr = this._rectToLocal(fr, r);
        ctx.strokeStyle = 'rgba(80,255,120,0.9)'; ctx.lineWidth = 2;
        ctx.strokeRect(rr.x, rr.y, rr.width, rr.height);
      }
      ctx.restore();
    };

    this._rectToLocal = (rect, base) => {
      // DOMRect(画面座標)→セーフエリア内座標
      const x = rect.left - base.left;
      const y = rect.top - base.top;
      const w = rect.width;
      const h = rect.height;
      return { x, y, width: w, height: h };
    };

    // 右上出現: 餌箱+エビ
    this._spawnEsabako = () => {
      if (!this._safe) return;
      if (this._esabakoGroup) { // 既にあれば再起動
        this._esabakoGroup.classList.remove('enter');
        void this._esabakoGroup.offsetWidth; // reflow
        this._esabakoGroup.classList.add('enter');
        return;
      }
      const g = document.createElement('div');
      g.className = 'esabako-group';
      g.innerHTML = `
        <picture>
          <source srcset="assets/esabako.webp" type="image/webp" />
          <img class="esabako-img" src="assets/esabako.png" alt="esabako"/>
        </picture>
        <img class="ebi-img" src="assets/taiwoturuebi.png" alt="ebi"/>
      `;
      this._safe.appendChild(g);
      this._esabakoGroup = g;
      // ebi を webp優先+フォールバックに
      try {
        const ebiImg = g.querySelector('.ebi-img');
        if (ebiImg) {
          ebiImg.decoding = 'async';
          const pngSrc = 'assets/taiwoturuebi.png';
          const webpSrc = 'assets/taiwoturuebi.webp';
          ebiImg.onerror = () => { if (ebiImg.src.endsWith('.webp')) { ebiImg.onerror = null; ebiImg.src = pngSrc; } };
          ebiImg.src = webpSrc;
        }
      } catch(_) {}
      // アニメ開始
      requestAnimationFrame(()=>{ g.classList.add('enter'); });
    };
  }

  

  unmount() {
    // フルスクリーン枠の解除
    document.body.classList.remove('frame-full');

    // リスナー類の解除
    if (this._onResize) window.removeEventListener('resize', this._onResize);
    if (this._ro) { try { this._ro.disconnect(); } catch(e) {} this._ro = null; }
    if (this._topsetRO) { try { this._topsetRO.disconnect(); } catch(_) {} this._topsetRO = null; }
    const video = this.root?.querySelector('#introVideo');
    if (video && this.onVideoError) video.removeEventListener('error', this.onVideoError);
    if (video && this._onVideoMeta) video.removeEventListener('loadedmetadata', this._onVideoMeta);
    if (this._onTap && this._layer) this._layer.removeEventListener('pointerdown', this._onTap);
    if (this._onPointerMove && this._safe) {
      this._safe.removeEventListener('pointermove', this._onPointerMove);
      this._safe.removeEventListener('pointerdown', this._onPointerMove);
    }
    if (this._onKeyDown) window.removeEventListener('keydown', this._onKeyDown);
    if (this._animRaf) cancelAnimationFrame(this._animRaf);
    if (this._baitFollowRaf) cancelAnimationFrame(this._baitFollowRaf);
    this._baitFollowRaf = null;
    this._stopBubbles?.();
    this._stopScrollBg?.();
    if (this._fade) this._fade.remove();
    if (this._bait && this._bait.unmount) this._bait.unmount();
    if (this._ropeCanvas) { try { this._ropeCanvas.remove(); } catch(_) {} this._ropeCanvas = null; }
    if (this._hitboxCanvas) { try { this._hitboxCanvas.remove(); } catch(_) {} this._hitboxCanvas = null; }
    if (this._scrollBg) this._scrollBg.remove();
    if (this._gameBlackBg) this._gameBlackBg.remove();
    if (this._esabakoGroup) { this._esabakoGroup.remove(); this._esabakoGroup = null; }
    if (this._tapGuideEl) { try { this._tapGuideEl.remove(); } catch(_) {} this._tapGuideEl = null; }
    if (this._speedBoostTimer) { try { clearTimeout(this._speedBoostTimer); } catch(_) {} this._speedBoostTimer = null; }
    try { this._stopSpeedStreaks?.(); } catch(_) {}
    const backBtn = this.root?.querySelector('#btnBack');
    if (backBtn) backBtn.removeEventListener('click', this.onBack);
    this.root?.remove();
    this.root = null;
}
}
